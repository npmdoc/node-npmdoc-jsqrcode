<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/vicapow/jsqrcode#readme"

    >jsqrcode (v0.0.7)</a>
</h1>
<h4>a node port of Lazar Laszlo's `jsqrcode` qr code decoder</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode">module jsqrcode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.jsqrcode">
            function <span class="apidocSignatureSpan"></span>jsqrcode
            <span class="apidocSignatureSpan">(Canvas)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.alignpat">
            function <span class="apidocSignatureSpan">jsqrcode.</span>alignpat
            <span class="apidocSignatureSpan">( image, startX, startY, width, height, moduleSize, resultPointCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.bitmat">
            function <span class="apidocSignatureSpan">jsqrcode.</span>bitmat
            <span class="apidocSignatureSpan">( width, height)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.bmparser">
            function <span class="apidocSignatureSpan">jsqrcode.</span>bmparser
            <span class="apidocSignatureSpan">(bitMatrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.datablock">
            function <span class="apidocSignatureSpan">jsqrcode.</span>datablock
            <span class="apidocSignatureSpan">(numDataCodewords, codewords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.databr">
            function <span class="apidocSignatureSpan">jsqrcode.</span>databr
            <span class="apidocSignatureSpan">(blocks, version, numErrorCorrectionCode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.detector">
            function <span class="apidocSignatureSpan">jsqrcode.</span>detector
            <span class="apidocSignatureSpan">(image)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.errorlevel">
            function <span class="apidocSignatureSpan">jsqrcode.</span>errorlevel
            <span class="apidocSignatureSpan">(ordinal, bits, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.findpat">
            function <span class="apidocSignatureSpan">jsqrcode.</span>findpat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.formatinf">
            function <span class="apidocSignatureSpan">jsqrcode.</span>formatinf
            <span class="apidocSignatureSpan">(formatInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.gf256">
            function <span class="apidocSignatureSpan">jsqrcode.</span>gf256
            <span class="apidocSignatureSpan">( primitive)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.gf256poly">
            function <span class="apidocSignatureSpan">jsqrcode.</span>gf256poly
            <span class="apidocSignatureSpan">(field, coefficients)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.perspective_transform">
            function <span class="apidocSignatureSpan">jsqrcode.</span>perspective_transform
            <span class="apidocSignatureSpan">( a11, a21, a31, a12, a22, a32, a13, a23, a33)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.rsdecoder">
            function <span class="apidocSignatureSpan">jsqrcode.</span>rsdecoder
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.toString">
            function <span class="apidocSignatureSpan">jsqrcode.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.version">
            function <span class="apidocSignatureSpan">jsqrcode.</span>version
            <span class="apidocSignatureSpan">( versionNumber, alignmentPatternCenters, ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.</span>datamask</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.</span>decoder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.</span>grid</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.alignpat">module jsqrcode.alignpat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.alignpat.alignpat">
            function <span class="apidocSignatureSpan">jsqrcode.</span>alignpat
            <span class="apidocSignatureSpan">( image, startX, startY, width, height, moduleSize, resultPointCallback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.bitmat">module jsqrcode.bitmat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.bitmat.bitmat">
            function <span class="apidocSignatureSpan">jsqrcode.</span>bitmat
            <span class="apidocSignatureSpan">( width, height)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.bmparser">module jsqrcode.bmparser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.bmparser.bmparser">
            function <span class="apidocSignatureSpan">jsqrcode.</span>bmparser
            <span class="apidocSignatureSpan">(bitMatrix)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.datablock">module jsqrcode.datablock</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.datablock.datablock">
            function <span class="apidocSignatureSpan">jsqrcode.</span>datablock
            <span class="apidocSignatureSpan">(numDataCodewords, codewords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.datablock.getDataBlocks">
            function <span class="apidocSignatureSpan">jsqrcode.datablock.</span>getDataBlocks
            <span class="apidocSignatureSpan">(rawCodewords, version, ecLevel)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.databr">module jsqrcode.databr</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.databr.databr">
            function <span class="apidocSignatureSpan">jsqrcode.</span>databr
            <span class="apidocSignatureSpan">(blocks, version, numErrorCorrectionCode)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.datamask">module jsqrcode.datamask</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.datamask.forReference">
            function <span class="apidocSignatureSpan">jsqrcode.datamask.</span>forReference
            <span class="apidocSignatureSpan">(reference)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.datamask.</span>DATA_MASKS</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.decoder">module jsqrcode.decoder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.decoder.correctErrors">
            function <span class="apidocSignatureSpan">jsqrcode.decoder.</span>correctErrors
            <span class="apidocSignatureSpan">( codewordBytes, numDataCodewords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.decoder.decode">
            function <span class="apidocSignatureSpan">jsqrcode.decoder.</span>decode
            <span class="apidocSignatureSpan">(bits)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.decoder.</span>rsDecoder</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.detector">module jsqrcode.detector</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.detector.detector">
            function <span class="apidocSignatureSpan">jsqrcode.</span>detector
            <span class="apidocSignatureSpan">(image)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.errorlevel">module jsqrcode.errorlevel</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.errorlevel.errorlevel">
            function <span class="apidocSignatureSpan">jsqrcode.</span>errorlevel
            <span class="apidocSignatureSpan">(ordinal, bits, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.errorlevel.forBits">
            function <span class="apidocSignatureSpan">jsqrcode.errorlevel.</span>forBits
            <span class="apidocSignatureSpan">( bits)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.findpat">module jsqrcode.findpat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.findpat.findpat">
            function <span class="apidocSignatureSpan">jsqrcode.</span>findpat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.formatinf">module jsqrcode.formatinf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.formatinf.formatinf">
            function <span class="apidocSignatureSpan">jsqrcode.</span>formatinf
            <span class="apidocSignatureSpan">(formatInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.formatinf.decodeFormatInformation">
            function <span class="apidocSignatureSpan">jsqrcode.formatinf.</span>decodeFormatInformation
            <span class="apidocSignatureSpan">( maskedFormatInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.formatinf.doDecodeFormatInformation">
            function <span class="apidocSignatureSpan">jsqrcode.formatinf.</span>doDecodeFormatInformation
            <span class="apidocSignatureSpan">( maskedFormatInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.formatinf.numBitsDiffering">
            function <span class="apidocSignatureSpan">jsqrcode.formatinf.</span>numBitsDiffering
            <span class="apidocSignatureSpan">( a, b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.gf256">module jsqrcode.gf256</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.gf256.gf256">
            function <span class="apidocSignatureSpan">jsqrcode.</span>gf256
            <span class="apidocSignatureSpan">( primitive)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.gf256.addOrSubtract">
            function <span class="apidocSignatureSpan">jsqrcode.gf256.</span>addOrSubtract
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.gf256.</span>DATA_MATRIX_FIELD</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.gf256.</span>QR_CODE_FIELD</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.gf256poly">module jsqrcode.gf256poly</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.gf256poly.gf256poly">
            function <span class="apidocSignatureSpan">jsqrcode.</span>gf256poly
            <span class="apidocSignatureSpan">(field, coefficients)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.grid">module jsqrcode.grid</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.grid.checkAndNudgePoints">
            function <span class="apidocSignatureSpan">jsqrcode.grid.</span>checkAndNudgePoints
            <span class="apidocSignatureSpan">( image, points)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.grid.sampleGrid3">
            function <span class="apidocSignatureSpan">jsqrcode.grid.</span>sampleGrid3
            <span class="apidocSignatureSpan">( image, dimension, transform)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.grid.sampleGridx">
            function <span class="apidocSignatureSpan">jsqrcode.grid.</span>sampleGridx
            <span class="apidocSignatureSpan">( image, dimension, p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY , p3FromX, p3FromY, p4FromX, p4FromY)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.perspective_transform">module jsqrcode.perspective_transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.perspective_transform.perspective_transform">
            function <span class="apidocSignatureSpan">jsqrcode.</span>perspective_transform
            <span class="apidocSignatureSpan">( a11, a21, a31, a12, a22, a32, a13, a23, a33)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.perspective_transform.quadrilateralToQuadrilateral">
            function <span class="apidocSignatureSpan">jsqrcode.perspective_transform.</span>quadrilateralToQuadrilateral
            <span class="apidocSignatureSpan">( x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.perspective_transform.quadrilateralToSquare">
            function <span class="apidocSignatureSpan">jsqrcode.perspective_transform.</span>quadrilateralToSquare
            <span class="apidocSignatureSpan">( x0, y0, x1, y1, x2, y2, x3, y3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.perspective_transform.squareToQuadrilateral">
            function <span class="apidocSignatureSpan">jsqrcode.perspective_transform.</span>squareToQuadrilateral
            <span class="apidocSignatureSpan">( x0, y0, x1, y1, x2, y2, x3, y3)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.rsdecoder">module jsqrcode.rsdecoder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.rsdecoder.rsdecoder">
            function <span class="apidocSignatureSpan">jsqrcode.</span>rsdecoder
            <span class="apidocSignatureSpan">(field)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.toString">module jsqrcode.toString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.toString.toString">
            function <span class="apidocSignatureSpan">jsqrcode.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.version">module jsqrcode.version</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.version.version">
            function <span class="apidocSignatureSpan">jsqrcode.</span>version
            <span class="apidocSignatureSpan">( versionNumber, alignmentPatternCenters, ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.version.decodeVersionInformation">
            function <span class="apidocSignatureSpan">jsqrcode.version.</span>decodeVersionInformation
            <span class="apidocSignatureSpan">( versionBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.version.getProvisionalVersionForDimension">
            function <span class="apidocSignatureSpan">jsqrcode.version.</span>getProvisionalVersionForDimension
            <span class="apidocSignatureSpan">(dimension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.version.getVersionForNumber">
            function <span class="apidocSignatureSpan">jsqrcode.version.</span>getVersionForNumber
            <span class="apidocSignatureSpan">( versionNumber)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.version.</span>VERSIONS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.version.</span>VERSION_DECODE_INFO</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode" id="apidoc.module.jsqrcode">module jsqrcode</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.jsqrcode" id="apidoc.element.jsqrcode.jsqrcode">
        function <span class="apidocSignatureSpan"></span>jsqrcode
        <span class="apidocSignatureSpan">(Canvas)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsqrcode = function (Canvas){
  // if the qrcode instance exists, return it
  if(qrcode) return qrcode;
  // if not, create it, then return it
  qrcode = {};
  var Image = null, isCanvas = null, createCanvas = null;

  if(typeof window!=&#x27;undefined&#x27;) {
    // XXX Fix for node-webkit not finding HTMLCanvasElement and document
    // outside window.
    HTMLCanvasElement = window.HTMLCanvasElement;
    document = window.document;

    // we&#x27;re in the browser
    if(typeof HTMLCanvasElement !== &#x27;undefined&#x27; ){
      createCanvas = function(width,height){
        var canvas = document.createElement(&#x22;canvas&#x22;);
        canvas.setAttribute(&#x27;width&#x27;, width);
        canvas.setAttribute(&#x27;height&#x27;, height);
        return canvas;
      }
    }else throw new Error(&#x22;the HTML5 Canvas element is not supported in &#x22;
      + &#x22;this browser&#x22;);
    Image = window.Image;
    if(!Image) throw new Error(&#x22;the Image element is not supported in &#x22;
      + &#x22;this browser&#x22;);
    isCanvas = function(instance){
      return instance instanceof HTMLCanvasElement;
    }
  }else{
    // // on the server!
    createCanvas = function(width,height){
      return new Canvas(width,height);
    }
    isCanvas = function(instance){
      return instance instanceof Canvas;
    }
    var s = require; //trick browserify into not including canvas
    if(!Canvas) Canvas = s(&#x27;canvas&#x27;);
    Image = Canvas.Image;
  }

  var Decoder = require(&#x27;./decoder&#x27;);
  var grid = require(&#x27;./grid&#x27;);
  var Detector = require(&#x27;./detector&#x27;);

  // TODO: remove this. should avoid extending built in types
  Array.prototype.remove = function(from, to) {
    var rest = this.slice((to || from) + 1 || this.length);
    this.length = from &#x3c; 0 ? this.length + from : from;
    return this.push.apply(this, rest);
  };


  qrcode.imagedata = null;
  qrcode.width = 0;
  qrcode.height = 0;
  qrcode.qrCodeSymbol = null;
  qrcode.debug = false;

  qrcode.sizeOfDataLengthInfo =  [  [ 10, 9, 8, 8 ],  [ 12, 11, 16, 10 ],  [ 14, 13, 16, 12 ] ];

  qrcode.decode = function(src){
    var canvas_qr = null
        , context = null;
    if( isCanvas(src) ){
      canvas_qr = src;
      context = canvas_qr.getContext(&#x27;2d&#x27;);
      qrcode.width = canvas_qr.width;
      qrcode.height = canvas_qr.height;
      qrcode.imagedata = context.getImageData(0, 0, qrcode.width, qrcode.height);
      return qrcode.process(context);
    }else if( src instanceof Image){
      return imageLoaded(src);
    }else{
      throw new Error(&#x27;jsqrcode can only decode a canvas or image element&#x27;);
    }
    function imageLoaded(image){
      canvas_qr = createCanvas(image.width, image.height);
      context = canvas_qr.getContext(&#x27;2d&#x27;);
      var canvas_out = createCanvas(image.width, image.height);
      if(canvas_out!==null){
        var outctx = canvas_out.getContext(&#x27;2d&#x27;);
        outctx.clearRect(0, 0, 320, 240);
        outctx.drawImage(image, 0, 0, 320, 240);
      }
      qrcode.width = canvas_qr.width;
      qrcode.height = canvas_qr.height;
      context.drawImage(image, 0, 0,canvas_qr.width,canvas_qr.height);
      try{
        qrcode.imagedata = context.getImageData(0, 0, canvas_qr.width, canvas_qr.height);
      }catch(e){
        throw new Error(&#x22;Cross domain image reading not supported in your &#x22;
          + &#x22;browser! Save it to your computer then drag and drop the file!&#x22;);
      }
      return qrcode.process(context);
    }
  }

  qrcode.decode_utf8 = function ( s ) {
    return decodeURIComponent( escape( s ) );
  }

  qrcode.process = function(ctx){
    var start = new Date().getTime();
    var image = qrcode.grayScaleToBitmap(qrcode.grayscale());
    //var image = qrcode.binarize(128);
    if(qrcode.debug){
      for (var y = 0; y &#x3c; qrcode.height; y++) {
        for (var x = 0; x &#x3c; qrcode.width; x++) {
          var point = (x * 4) + (y * qrcode.width * 4);
          qrcode.imagedata.data[point] = image[x+y*qrcode.width]?0:0;
          qrcode.imagedata.data[point+1] = image[x+y*qrcode.width]?0:0;
          qrcode.image ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.alignpat" id="apidoc.element.jsqrcode.alignpat">
        function <span class="apidocSignatureSpan">jsqrcode.</span>alignpat
        <span class="apidocSignatureSpan">( image, startX, startY, width, height, moduleSize, resultPointCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AlignmentPatternFinder( image, startX, startY, width, height, moduleSize, resultPointCallback)
{
  this.image = image;
  this.possibleCenters = new Array();
  this.startX = startX;
  this.startY = startY;
  this.width = width;
  this.height = height;
  this.moduleSize = moduleSize;
  this.crossCheckStateCount = new Array(0,0,0);
  this.resultPointCallback = resultPointCallback;

  this.centerFromEnd=function(stateCount,  end)
    {
      return  (end - stateCount[2]) - stateCount[1] / 2.0;
    }
  this.foundPatternCross = function(stateCount)
    {
      var moduleSize = this.moduleSize;
      var maxVariance = moduleSize / 2.0;
      for (var i = 0; i &#x3c; 3; i++)
      {
        if (Math.abs(moduleSize - stateCount[i]) &#x3e;= maxVariance)
        {
          return false;
        }
      }
      return true;
    }

  this.crossCheckVertical=function( startI,  centerJ,  maxCount,  originalStateCountTotal)
    {
      var image = this.image;

      var maxI = qrcode.height;
      var stateCount = this.crossCheckStateCount;
      stateCount[0] = 0;
      stateCount[1] = 0;
      stateCount[2] = 0;

      // Start counting up from center
      var i = startI;
      while (i &#x3e;= 0 &#x26;&#x26; image[centerJ + i*qrcode.width] &#x26;&#x26; stateCount[1] &#x3c;= maxCount)
      {
        stateCount[1]++;
        i--;
      }
      // If already too many modules in this state or ran off the edge:
      if (i &#x3c; 0 || stateCount[1] &#x3e; maxCount)
      {
        return NaN;
      }
      while (i &#x3e;= 0 &#x26;&#x26; !image[centerJ + i*qrcode.width] &#x26;&#x26; stateCount[0] &#x3c;= maxCount)
      {
        stateCount[0]++;
        i--;
      }
      if (stateCount[0] &#x3e; maxCount)
      {
        return NaN;
      }

      // Now also count down from center
      i = startI + 1;
      while (i &#x3c; maxI &#x26;&#x26; image[centerJ + i*qrcode.width] &#x26;&#x26; stateCount[1] &#x3c;= maxCount)
      {
        stateCount[1]++;
        i++;
      }
      if (i == maxI || stateCount[1] &#x3e; maxCount)
      {
        return NaN;
      }
      while (i &#x3c; maxI &#x26;&#x26; !image[centerJ + i*qrcode.width] &#x26;&#x26; stateCount[2] &#x3c;= maxCount)
      {
        stateCount[2]++;
        i++;
      }
      if (stateCount[2] &#x3e; maxCount)
      {
        return NaN;
      }

      var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
      if (5 * Math.abs(stateCountTotal - originalStateCountTotal) &#x3e;= 2 * originalStateCountTotal)
      {
        return NaN;
      }

      return this.foundPatternCross(stateCount)?this.centerFromEnd(stateCount, i):NaN;
    }

  this.handlePossibleCenter=function( stateCount,  i,  j)
    {
      var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
      var centerJ = this.centerFromEnd(stateCount, j);
      var centerI = this.crossCheckVertical(i, Math.floor (centerJ), 2 * stateCount[1], stateCountTotal);
      if (!isNaN(centerI))
      {
        var estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;
        var max = this.possibleCenters.length;
        for (var index = 0; index &#x3c; max; index++)
        {
          var center =  this.possibleCenters[index];
          // Look for about the same center and module size:
          if (center.aboutEquals(estimatedModuleSize, centerI, centerJ))
          {
            return new AlignmentPattern(centerJ, centerI, estimatedModuleSize);
          }
        }
        // Hadn&#x27;t found this before; save it
        var point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);
        this.possibleCenters.push(point);
        if (this.resultPointCallback != null)
        {
          this.resultPointCallback.foundPossibleResultPoint(point);
        }
      }
      return null;
    }

  this.find = function()
  {
      var startX = this.startX;
      var height = this.height;
      var maxJ = startX + width;
      var middleI = startY + (height &#x3e;&#x3e; 1);
      // We are looking for black/white/black modules in 1:1:1 ratio;
      // this tracks th ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.bitmat" id="apidoc.element.jsqrcode.bitmat">
        function <span class="apidocSignatureSpan">jsqrcode.</span>bitmat
        <span class="apidocSignatureSpan">( width, height)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BitMatrix( width, height) {
  if(!height)
    height=width;
  if (width &#x3c; 1 || height &#x3c; 1)
  {
    throw &#x22;Both dimensions must be greater than 0&#x22;;
  }
  this.width = width;
  this.height = height;
  var rowSize = width &#x3e;&#x3e; 5;
  if ((width &#x26; 0x1f) != 0)
  {
    rowSize++;
  }
  this.rowSize = rowSize;
  this.bits = new Array(rowSize * height);
  for(var i=0;i&#x3c;this.bits.length;i++)
    this.bits[i]=0;

  this.__defineGetter__(&#x22;Width&#x22;, function()
  {
    return this.width;
  });
  this.__defineGetter__(&#x22;Height&#x22;, function()
  {
    return this.height;
  });
  this.__defineGetter__(&#x22;Dimension&#x22;, function()
  {
    if (this.width != this.height)
    {
      throw &#x22;Can&#x27;t call getDimension() on a non-square matrix&#x22;;
    }
    return this.width;
  });

  this.get_Renamed=function( x,  y)
    {
      var offset = y * this.rowSize + (x &#x3e;&#x3e; 5);
      return ((qrcode.URShift(this.bits[offset], (x &#x26; 0x1f))) &#x26; 1) != 0;
    }
  this.set_Renamed=function( x,  y)
    {
      var offset = y * this.rowSize + (x &#x3e;&#x3e; 5);
      this.bits[offset] |= 1 &#x3c;&#x3c; (x &#x26; 0x1f);
    }
  this.flip=function( x,  y)
    {
      var offset = y * this.rowSize + (x &#x3e;&#x3e; 5);
      this.bits[offset] ^= 1 &#x3c;&#x3c; (x &#x26; 0x1f);
    }
  this.clear=function()
    {
      var max = this.bits.length;
      for (var i = 0; i &#x3c; max; i++)
      {
        this.bits[i] = 0;
      }
    }
  this.setRegion=function( left,  top,  width,  height)
    {
      if (top &#x3c; 0 || left &#x3c; 0)
      {
        throw &#x22;Left and top must be nonnegative&#x22;;
      }
      if (height &#x3c; 1 || width &#x3c; 1)
      {
        throw &#x22;Height and width must be at least 1&#x22;;
      }
      var right = left + width;
      var bottom = top + height;
      if (bottom &#x3e; this.height || right &#x3e; this.width)
      {
        throw &#x22;The region must fit inside the matrix&#x22;;
      }
      for (var y = top; y &#x3c; bottom; y++)
      {
        var offset = y * this.rowSize;
        for (var x = left; x &#x3c; right; x++)
        {
          this.bits[offset + (x &#x3e;&#x3e; 5)] |= 1 &#x3c;&#x3c; (x &#x26; 0x1f);
        }
      }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.bmparser" id="apidoc.element.jsqrcode.bmparser">
        function <span class="apidocSignatureSpan">jsqrcode.</span>bmparser
        <span class="apidocSignatureSpan">(bitMatrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BitMatrixParser(bitMatrix)
{
  var dimension = bitMatrix.Dimension;
  if (dimension &#x3c; 21 || (dimension &#x26; 0x03) != 1)
  {
    throw &#x22;Error BitMatrixParser&#x22;;
  }
  this.bitMatrix = bitMatrix;
  this.parsedVersion = null;
  this.parsedFormatInfo = null;

  this.copyBit=function( i,  j,  versionBits)
  {
    return this.bitMatrix.get_Renamed(i, j)?(versionBits &#x3c;&#x3c; 1) | 0x1:versionBits &#x3c;&#x3c; 1;
  }

  this.readFormatInformation=function()
  {
      if (this.parsedFormatInfo != null)
      {
        return this.parsedFormatInfo;
      }

      // Read top-left format info bits
      var formatInfoBits = 0;
      for (var i = 0; i &#x3c; 6; i++)
      {
        formatInfoBits = this.copyBit(i, 8, formatInfoBits);
      }
      // .. and skip a bit in the timing pattern ...
      formatInfoBits = this.copyBit(7, 8, formatInfoBits);
      formatInfoBits = this.copyBit(8, 8, formatInfoBits);
      formatInfoBits = this.copyBit(8, 7, formatInfoBits);
      // .. and skip a bit in the timing pattern ...
      for (var j = 5; j &#x3e;= 0; j--)
      {
        formatInfoBits = this.copyBit(8, j, formatInfoBits);
      }

      this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits);
      if (this.parsedFormatInfo != null)
      {
        return this.parsedFormatInfo;
      }

      // Hmm, failed. Try the top-right/bottom-left pattern
      var dimension = this.bitMatrix.Dimension;
      formatInfoBits = 0;
      var iMin = dimension - 8;
      for (var i = dimension - 1; i &#x3e;= iMin; i--)
      {
        formatInfoBits = this.copyBit(i, 8, formatInfoBits);
      }
      for (var j = dimension - 7; j &#x3c; dimension; j++)
      {
        formatInfoBits = this.copyBit(8, j, formatInfoBits);
      }

      this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits);
      if (this.parsedFormatInfo != null)
      {
        return this.parsedFormatInfo;
      }
      throw &#x22;Error readFormatInformation&#x22;;
  }
  this.readVersion=function()
    {

      if (this.parsedVersion != null)
      {
        return this.parsedVersion;
      }

      var dimension = this.bitMatrix.Dimension;

      var provisionalVersion = (dimension - 17) &#x3e;&#x3e; 2;
      if (provisionalVersion &#x3c;= 6)
      {
        return Version.getVersionForNumber(provisionalVersion);
      }

      // Read top-right version info: 3 wide by 6 tall
      var versionBits = 0;
      var ijMin = dimension - 11;
      for (var j = 5; j &#x3e;= 0; j--)
      {
        for (var i = dimension - 9; i &#x3e;= ijMin; i--)
        {
          versionBits = this.copyBit(i, j, versionBits);
        }
      }

      this.parsedVersion = Version.decodeVersionInformation(versionBits);
      if (this.parsedVersion != null &#x26;&#x26; this.parsedVersion.DimensionForVersion == dimension)
      {
        return this.parsedVersion;
      }

      // Hmm, failed. Try bottom left: 6 wide by 3 tall
      versionBits = 0;
      for (var i = 5; i &#x3e;= 0; i--)
      {
        for (var j = dimension - 9; j &#x3e;= ijMin; j--)
        {
          versionBits = this.copyBit(i, j, versionBits);
        }
      }

      this.parsedVersion = Version.decodeVersionInformation(versionBits);
      if (this.parsedVersion != null &#x26;&#x26; this.parsedVersion.DimensionForVersion == dimension)
      {
        return this.parsedVersion;
      }
      throw &#x22;Error readVersion&#x22;;
    }
  this.readCodewords=function()
    {

      var formatInfo = this.readFormatInformation();
      var version = this.readVersion();

      // Get the data mask for the format used in this QR Code. This will exclude
      // some bits from reading as we wind through the bit matrix.
      var dataMask = DataMask.forReference( formatInfo.DataMask);
      var dimension = this.bitMatrix.Dimension;
      dataMask.unmaskBitMatrix(this.bitMatrix, dimension);

      var functionPattern = version.buildFunctionPattern();

      var re ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.datablock" id="apidoc.element.jsqrcode.datablock">
        function <span class="apidocSignatureSpan">jsqrcode.</span>datablock
        <span class="apidocSignatureSpan">(numDataCodewords, codewords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataBlock(numDataCodewords, codewords)
{
	this.numDataCodewords = numDataCodewords;
	this.codewords = codewords;
	
	this.__defineGetter__(&#x22;NumDataCodewords&#x22;, function()
	{
		return this.numDataCodewords;
	});
	this.__defineGetter__(&#x22;Codewords&#x22;, function()
	{
		return this.codewords;
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.databr" id="apidoc.element.jsqrcode.databr">
        function <span class="apidocSignatureSpan">jsqrcode.</span>databr
        <span class="apidocSignatureSpan">(blocks, version, numErrorCorrectionCode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QRCodeDataBlockReader(blocks, version, numErrorCorrectionCode)
{
  this.blockPointer = 0;
  this.bitPointer = 7;
  this.dataLength = 0;
  this.blocks = blocks;
  this.numErrorCorrectionCode = numErrorCorrectionCode;
  if (version &#x3c;= 9)
    this.dataLengthMode = 0;
  else if (version &#x3e;= 10 &#x26;&#x26; version &#x3c;= 26)
    this.dataLengthMode = 1;
  else if (version &#x3e;= 27 &#x26;&#x26; version &#x3c;= 40)
    this.dataLengthMode = 2;

  this.getNextBits = function( numBits)
    {
      var bits = 0;
      if (numBits &#x3c; this.bitPointer + 1)
      {
        // next word fits into current data block
        var mask = 0;
        for (var i = 0; i &#x3c; numBits; i++)
        {
          mask += (1 &#x3c;&#x3c; i);
        }
        mask &#x3c;&#x3c;= (this.bitPointer - numBits + 1);

        bits = (this.blocks[this.blockPointer] &#x26; mask) &#x3e;&#x3e; (this.bitPointer - numBits + 1);
        this.bitPointer -= numBits;
        return bits;
      }
      else if (numBits &#x3c; this.bitPointer + 1 + 8)
      {
        // next word crosses 2 data blocks
        var mask1 = 0;
        for (var i = 0; i &#x3c; this.bitPointer + 1; i++)
        {
          mask1 += (1 &#x3c;&#x3c; i);
        }
        bits = (this.blocks[this.blockPointer] &#x26; mask1) &#x3c;&#x3c; (numBits - (this.bitPointer + 1));
                this.blockPointer++;
        bits += ((this.blocks[this.blockPointer]) &#x3e;&#x3e; (8 - (numBits - (this.bitPointer + 1))));

        this.bitPointer = this.bitPointer - numBits % 8;
        if (this.bitPointer &#x3c; 0)
        {
          this.bitPointer = 8 + this.bitPointer;
        }
        return bits;
      }
      else if (numBits &#x3c; this.bitPointer + 1 + 16)
      {
        // next word crosses 3 data blocks
        var mask1 = 0; // mask of first block
        var mask3 = 0; // mask of 3rd block
        //bitPointer + 1 : number of bits of the 1st block
        //8 : number of the 2nd block (note that use already 8bits because next word uses 3 data blocks)
        //numBits - (bitPointer + 1 + 8) : number of bits of the 3rd block
        for (var i = 0; i &#x3c; this.bitPointer + 1; i++)
        {
          mask1 += (1 &#x3c;&#x3c; i);
        }
        var bitsFirstBlock = (this.blocks[this.blockPointer] &#x26; mask1) &#x3c;&#x3c; (numBits - (this.bitPointer + 1));
        this.blockPointer++;

        var bitsSecondBlock = this.blocks[this.blockPointer] &#x3c;&#x3c; (numBits - (this.bitPointer + 1 + 8));
        this.blockPointer++;

        for (var i = 0; i &#x3c; numBits - (this.bitPointer + 1 + 8); i++)
        {
          mask3 += (1 &#x3c;&#x3c; i);
        }
        mask3 &#x3c;&#x3c;= 8 - (numBits - (this.bitPointer + 1 + 8));
        var bitsThirdBlock = (this.blocks[this.blockPointer] &#x26; mask3) &#x3e;&#x3e; (8 - (numBits - (this.bitPointer + 1 + 8)));

        bits = bitsFirstBlock + bitsSecondBlock + bitsThirdBlock;
        this.bitPointer = this.bitPointer - (numBits - 8) % 8;
        if (this.bitPointer &#x3c; 0)
        {
          this.bitPointer = 8 + this.bitPointer;
        }
        return bits;
      }
      else
      {
        return 0;
      }
    }
  this.NextMode=function()
  {
    if ((this.blockPointer &#x3e; this.blocks.length - this.numErrorCorrectionCode - 2))
      return 0;
    else
      return this.getNextBits(4);
  }
  this.getDataLength=function( modeIndicator)
    {
      var index = 0;
      while (true)
      {
        if ((modeIndicator &#x3e;&#x3e; index) == 1)
          break;
        index++;
      }

      return this.getNextBits(qrcode.sizeOfDataLengthInfo[this.dataLengthMode][index]);
    }
  this.getRomanAndFigureString=function( dataLength)
    {
      var length = dataLength;
      var intData = 0;
      var strData = &#x22;&#x22;;
      var tableRomanAndFigure = new Array(&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;
H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27; &#x27;, &#x27;$&#x27;, &#x27;%&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;-&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, &#x27;:&#x27;);
      do
      {
        if (length &#x3e; 1)
        {
          intData = this.getNextBits(11); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.detector" id="apidoc.element.jsqrcode.detector">
        function <span class="apidocSignatureSpan">jsqrcode.</span>detector
        <span class="apidocSignatureSpan">(image)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Detector(image)
{
  this.image=image;
  this.resultPointCallback = null;

  this.sizeOfBlackWhiteBlackRun=function( fromX,  fromY,  toX,  toY)
    {
      // Mild variant of Bresenham&#x27;s algorithm;
      // see http://en.wikipedia.org/wiki/Bresenham&#x27;s_line_algorithm
      var steep = Math.abs(toY - fromY) &#x3e; Math.abs(toX - fromX);
      if (steep)
      {
        var temp = fromX;
        fromX = fromY;
        fromY = temp;
        temp = toX;
        toX = toY;
        toY = temp;
      }

      var dx = Math.abs(toX - fromX);
      var dy = Math.abs(toY - fromY);
      var error = - dx &#x3e;&#x3e; 1;
      var ystep = fromY &#x3c; toY?1:- 1;
      var xstep = fromX &#x3c; toX?1:- 1;
      var state = 0; // In black pixels, looking for white, first or second time
      for (var x = fromX, y = fromY; x != toX; x += xstep)
      {

        var realX = steep?y:x;
        var realY = steep?x:y;
        if (state == 1)
        {
          // In white pixels, looking for black
          if (this.image[realX + realY*qrcode.width])
          {
            state++;
          }
        }
        else
        {
          if (!this.image[realX + realY*qrcode.width])
          {
            state++;
          }
        }

        if (state == 3)
        {
          // Found black, white, black, and stumbled back onto white; done
          var diffX = x - fromX;
          var diffY = y - fromY;
          return  Math.sqrt( (diffX * diffX + diffY * diffY));
        }
        error += dy;
        if (error &#x3e; 0)
        {
          if (y == toY)
          {
            break;
          }
          y += ystep;
          error -= dx;
        }
      }
      var diffX2 = toX - fromX;
      var diffY2 = toY - fromY;
      return  Math.sqrt( (diffX2 * diffX2 + diffY2 * diffY2));
    }


  this.sizeOfBlackWhiteBlackRunBothWays=function( fromX,  fromY,  toX,  toY)
    {

      var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);

      // Now count other way -- don&#x27;t run off image though of course
      var scale = 1.0;
      var otherToX = fromX - (toX - fromX);
      if (otherToX &#x3c; 0)
      {
        scale =  fromX /  (fromX - otherToX);
        otherToX = 0;
      }
      else if (otherToX &#x3e;= qrcode.width)
      {
        scale =  (qrcode.width - 1 - fromX) /  (otherToX - fromX);
        otherToX = qrcode.width - 1;
      }
      var otherToY = Math.floor (fromY - (toY - fromY) * scale);

      scale = 1.0;
      if (otherToY &#x3c; 0)
      {
        scale =  fromY /  (fromY - otherToY);
        otherToY = 0;
      }
      else if (otherToY &#x3e;= qrcode.height)
      {
        scale =  (qrcode.height - 1 - fromY) /  (otherToY - fromY);
        otherToY = qrcode.height - 1;
      }
      otherToX = Math.floor (fromX + (otherToX - fromX) * scale);

      result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
      return result - 1.0; // -1 because we counted the middle pixel twice
    }



  this.calculateModuleSizeOneWay=function( pattern,  otherPattern)
    {
      var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor( pattern.X), Math.floor( pattern.Y), Math.floor( otherPattern
.X), Math.floor(otherPattern.Y));
      var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(otherPattern.X), Math.floor(otherPattern.Y), Math.floor
( pattern.X), Math.floor(pattern.Y));
      if (isNaN(moduleSizeEst1))
      {
        return moduleSizeEst2 / 7.0;
      }
      if (isNaN(moduleSizeEst2))
      {
        return moduleSizeEst1 / 7.0;
      }
      // Average them, and divide by 7 since we&#x27;ve counted the width of 3 black modules,
      // and 1 white and 1 black module on either side. Ergo, divide sum by 14.
      return (moduleSizeEst1 + moduleSizeEst2) / 14.0;
    }


  this.calculateModuleSize=function( topLeft,  topRight,  bottomLeft)
    {
      // Take the average
      return (this.calculateModuleSizeOneWay(topL ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.errorlevel" id="apidoc.element.jsqrcode.errorlevel">
        function <span class="apidocSignatureSpan">jsqrcode.</span>errorlevel
        <span class="apidocSignatureSpan">(ordinal, bits, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ErrorCorrectionLevel(ordinal, bits, name)
{
	this.ordinal_Renamed_Field = ordinal;
	this.bits = bits;
	this.name = name;
	this.__defineGetter__(&#x22;Bits&#x22;, function()
	{
		return this.bits;
	});
	this.__defineGetter__(&#x22;Name&#x22;, function()
	{
		return this.name;
	});
	this.ordinal=function()
	{
		return this.ordinal_Renamed_Field;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.findpat" id="apidoc.element.jsqrcode.findpat">
        function <span class="apidocSignatureSpan">jsqrcode.</span>findpat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FinderPatternFinder()
{
  this.image=null;
  this.possibleCenters = [];
  this.hasSkipped = false;
  this.crossCheckStateCount = new Array(0,0,0,0,0);
  this.resultPointCallback = null;

  this.__defineGetter__(&#x22;CrossCheckStateCount&#x22;, function()
  {
    this.crossCheckStateCount[0] = 0;
    this.crossCheckStateCount[1] = 0;
    this.crossCheckStateCount[2] = 0;
    this.crossCheckStateCount[3] = 0;
    this.crossCheckStateCount[4] = 0;
    return this.crossCheckStateCount;
  });

  this.foundPatternCross=function( stateCount)
    {
      var totalModuleSize = 0;
      for (var i = 0; i &#x3c; 5; i++)
      {
        var count = stateCount[i];
        if (count == 0)
        {
          return false;
        }
        totalModuleSize += count;
      }
      if (totalModuleSize &#x3c; 7)
      {
        return false;
      }
      var moduleSize = Math.floor((totalModuleSize &#x3c;&#x3c; INTEGER_MATH_SHIFT) / 7);
      var maxVariance = Math.floor(moduleSize / 2);
      // Allow less than 50% variance from 1-1-3-1-1 proportions
      return Math.abs(moduleSize - (stateCount[0] &#x3c;&#x3c; INTEGER_MATH_SHIFT)) &#x3c; maxVariance &#x26;&#x26; Math.abs(moduleSize - (stateCount[1] &#x3c;&#x3c;
INTEGER_MATH_SHIFT)) &#x3c; maxVariance &#x26;&#x26; Math.abs(3 * moduleSize - (stateCount[2] &#x3c;&#x3c; INTEGER_MATH_SHIFT)) &#x3c; 3 * maxVariance &#x26;&#x26; Math
.abs(moduleSize - (stateCount[3] &#x3c;&#x3c; INTEGER_MATH_SHIFT)) &#x3c; maxVariance &#x26;&#x26; Math.abs(moduleSize - (stateCount[4] &#x3c;&#x3c; INTEGER_MATH_SHIFT
)) &#x3c; maxVariance;
    }
  this.centerFromEnd=function( stateCount,  end)
    {
      return  (end - stateCount[4] - stateCount[3]) - stateCount[2] / 2.0;
    }
  this.crossCheckVertical=function( startI,  centerJ,  maxCount,  originalStateCountTotal)
    {
      var image = this.image;

      var maxI = qrcode.height;
      var stateCount = this.CrossCheckStateCount;

      // Start counting up from center
      var i = startI;
      while (i &#x3e;= 0 &#x26;&#x26; image[centerJ + i*qrcode.width])
      {
        stateCount[2]++;
        i--;
      }
      if (i &#x3c; 0)
      {
        return NaN;
      }
      while (i &#x3e;= 0 &#x26;&#x26; !image[centerJ +i*qrcode.width] &#x26;&#x26; stateCount[1] &#x3c;= maxCount)
      {
        stateCount[1]++;
        i--;
      }
      // If already too many modules in this state or ran off the edge:
      if (i &#x3c; 0 || stateCount[1] &#x3e; maxCount)
      {
        return NaN;
      }
      while (i &#x3e;= 0 &#x26;&#x26; image[centerJ + i*qrcode.width] &#x26;&#x26; stateCount[0] &#x3c;= maxCount)
      {
        stateCount[0]++;
        i--;
      }
      if (stateCount[0] &#x3e; maxCount)
      {
        return NaN;
      }

      // Now also count down from center
      i = startI + 1;
      while (i &#x3c; maxI &#x26;&#x26; image[centerJ +i*qrcode.width])
      {
        stateCount[2]++;
        i++;
      }
      if (i == maxI)
      {
        return NaN;
      }
      while (i &#x3c; maxI &#x26;&#x26; !image[centerJ + i*qrcode.width] &#x26;&#x26; stateCount[3] &#x3c; maxCount)
      {
        stateCount[3]++;
        i++;
      }
      if (i == maxI || stateCount[3] &#x3e;= maxCount)
      {
        return NaN;
      }
      while (i &#x3c; maxI &#x26;&#x26; image[centerJ + i*qrcode.width] &#x26;&#x26; stateCount[4] &#x3c; maxCount)
      {
        stateCount[4]++;
        i++;
      }
      if (stateCount[4] &#x3e;= maxCount)
      {
        return NaN;
      }

      // If we found a finder-pattern-like section, but its size is more than 40% different than
      // the original, assume it&#x27;s a false positive
      var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
      if (5 * Math.abs(stateCountTotal - originalStateCountTotal) &#x3e;= 2 * originalStateCountTotal)
      {
        return NaN;
      }

      return this.foundPatternCross(stateCount)?this.centerFromEnd(stateCount, i):NaN;
    }
  this.crossCheckHorizontal=function( startJ,  centerI,  maxCount, originalStateCountTotal)
    {
      var image = this.image;

      var maxJ = qrcode.width;
      var stateCount = this.CrossCheckStateCount;

      var j = startJ;
      wh ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.formatinf" id="apidoc.element.jsqrcode.formatinf">
        function <span class="apidocSignatureSpan">jsqrcode.</span>formatinf
        <span class="apidocSignatureSpan">(formatInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FormatInformation(formatInfo)
{
	this.errorCorrectionLevel = ErrorCorrectionLevel.forBits((formatInfo &#x3e;&#x3e; 3) &#x26; 0x03);
	this.dataMask =  (formatInfo &#x26; 0x07);

	this.__defineGetter__(&#x22;ErrorCorrectionLevel&#x22;, function()
	{
		return this.errorCorrectionLevel;
	});
	this.__defineGetter__(&#x22;DataMask&#x22;, function()
	{
		return this.dataMask;
	});
	this.GetHashCode=function()
	{
		return (this.errorCorrectionLevel.ordinal() &#x3c;&#x3c; 3) |  dataMask;
	}
	this.Equals=function( o)
	{
		var other =  o;
		return this.errorCorrectionLevel == other.errorCorrectionLevel &#x26;&#x26; this.dataMask == other.dataMask;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.gf256" id="apidoc.element.jsqrcode.gf256">
        function <span class="apidocSignatureSpan">jsqrcode.</span>gf256
        <span class="apidocSignatureSpan">( primitive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gf256 = function ( primitive)
{
  this.expTable = new Array(256);
  this.logTable = new Array(256);
  // delayed dep injection
  if(!GF256Poly) GF256Poly = require(&#x27;./gf256poly&#x27;);
  var x = 1;
  for (var i = 0; i &#x3c; 256; i++)
  {
    this.expTable[i] = x;
    x &#x3c;&#x3c;= 1; // x = x * 2; we&#x27;re assuming the generator alpha is 2
    if (x &#x3e;= 0x100)
    {
      x ^= primitive;
    }
  }
  for (var i = 0; i &#x3c; 255; i++)
  {
    this.logTable[this.expTable[i]] = i;
  }
  // logTable[0] == 0 but this should never be used
  var at0=new Array(1);at0[0]=0;
  this.zero = new GF256Poly(this, new Array(at0));
  var at1=new Array(1);at1[0]=1;
  this.one = new GF256Poly(this, new Array(at1));

  this.__defineGetter__(&#x22;Zero&#x22;, function()
  {
    return this.zero;
  });
  this.__defineGetter__(&#x22;One&#x22;, function()
  {
    return this.one;
  });
  this.buildMonomial=function( degree,  coefficient)
    {
      if (degree &#x3c; 0)
      {
        throw &#x22;System.ArgumentException&#x22;;
      }
      if (coefficient == 0)
      {
        return zero;
      }
      var coefficients = new Array(degree + 1);
      for(var i=0;i&#x3c;coefficients.length;i++)coefficients[i]=0;
      coefficients[0] = coefficient;
      return new GF256Poly(this, coefficients);
    }
  this.exp=function(a)
    {
      return this.expTable[a];
    }
  this.log=function(a)
    {
      if (a == 0)
      {
        throw &#x22;System.ArgumentException&#x22;;
      }
      return this.logTable[a];
    }
  this.inverse=function(a)
    {
      if (a == 0)
      {
        throw &#x22;System.ArithmeticException&#x22;;
      }
      return this.expTable[255 - this.logTable[a]];
    }
  this.multiply=function(a, b) {
    if (a == 0 || b == 0) return 0;
    else if (a == 1) return b;
    else if (b == 1) return a;
    return this.expTable[(this.logTable[a] + this.logTable[b]) % 255];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.gf256poly" id="apidoc.element.jsqrcode.gf256poly">
        function <span class="apidocSignatureSpan">jsqrcode.</span>gf256poly
        <span class="apidocSignatureSpan">(field, coefficients)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function GF256Poly(field, coefficients)
{
  if (coefficients == null || coefficients.length == 0)
    throw new Error(&#x22;GF256Poly bad arguments. no coefficients provided&#x22;);
  if(!GF256) GF256 = require(&#x27;./gf256&#x27;);
  this.field = field;
  var coefficientsLength = coefficients.length;
  if (coefficientsLength &#x3e; 1 &#x26;&#x26; coefficients[0] == 0)
  {
    // Leading term must be non-zero for anything except the constant polynomial &#x22;0&#x22;
    var firstNonZero = 1;
    while (firstNonZero &#x3c; coefficientsLength &#x26;&#x26; coefficients[firstNonZero] == 0)
    {
      firstNonZero++;
    }
    if (firstNonZero == coefficientsLength)
    {
      this.coefficients = field.Zero.coefficients;
    }
    else
    {
      this.coefficients = new Array(coefficientsLength - firstNonZero);
      for(var i=0;i&#x3c;this.coefficients.length;i++)this.coefficients[i]=0;
      //Array.Copy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
      for(var ci=0;ci&#x3c;this.coefficients.length;ci++)this.coefficients[ci]=coefficients[firstNonZero+ci];
    }
  }
  else
  {
    this.coefficients = coefficients;
  }

  this.__defineGetter__(&#x22;Zero&#x22;, function()
  {
    return this.coefficients[0] == 0;
  });
  this.__defineGetter__(&#x22;Degree&#x22;, function()
  {
    return this.coefficients.length - 1;
  });
  this.__defineGetter__(&#x22;Coefficients&#x22;, function()
  {
    return this.coefficients;
  });

  this.getCoefficient=function( degree)
  {
    return this.coefficients[this.coefficients.length - 1 - degree];
  }

  this.evaluateAt=function( a)
  {
    if (a == 0)
    {
      // Just return the x^0 coefficient
      return this.getCoefficient(0);
    }
    var size = this.coefficients.length;
    if (a == 1)
    {
      // Just the sum of the coefficients
      var result = 0;
      for (var i = 0; i &#x3c; size; i++) {
        result = GF256.addOrSubtract(result, this.coefficients[i]);
      }
      return result;
    }
    var result2 = this.coefficients[0];
    for (var i = 1; i &#x3c; size; i++)
    {
      result2 = GF256.addOrSubtract(this.field.multiply(a, result2), this.coefficients[i]);
    }
    return result2;
  }

  this.addOrSubtract = function( other)
    {
      if (this.field != other.field)
      {
        throw &#x22;GF256Polys do not have same GF256 field&#x22;;
      }
      if (this.Zero)
      {
        return other;
      }
      if (other.Zero)
      {
        return this;
      }

      var smallerCoefficients = this.coefficients;
      var largerCoefficients = other.coefficients;
      if (smallerCoefficients.length &#x3e; largerCoefficients.length)
      {
        var temp = smallerCoefficients;
        smallerCoefficients = largerCoefficients;
        largerCoefficients = temp;
      }
      var sumDiff = new Array(largerCoefficients.length);
      var lengthDiff = largerCoefficients.length - smallerCoefficients.length;
      // Copy high-order terms only found in higher-degree polynomial&#x27;s coefficients
      //Array.Copy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
      for(var ci=0;ci&#x3c;lengthDiff;ci++)sumDiff[ci]=largerCoefficients[ci];

      for (var i = lengthDiff; i &#x3c; largerCoefficients.length; i++)
      {
        sumDiff[i] = GF256.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
      }

      return new GF256Poly(field, sumDiff);
  }
  this.multiply1=function( other)
    {
      if (this.field!=other.field)
      {
        throw &#x22;GF256Polys do not have same GF256 field&#x22;;
      }
      if (this.Zero || other.Zero)
      {
        return this.field.Zero;
      }
      var aCoefficients = this.coefficients;
      var aLength = aCoefficients.length;
      var bCoefficients = other.coefficients;
      var bLength = bCoefficients.length;
      var product = new Array(aLength + bLength - 1);
      for (var i = 0; i &#x3c; aLength; i++)
      {
        var aCoeff = aCoefficients[i];
        for (var j = 0; j &#x3c; bLength; j++)
        {
          product[i + j] = GF256.addOrSubtract ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.perspective_transform" id="apidoc.element.jsqrcode.perspective_transform">
        function <span class="apidocSignatureSpan">jsqrcode.</span>perspective_transform
        <span class="apidocSignatureSpan">( a11, a21, a31, a12, a22, a32, a13, a23, a33)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PerspectiveTransform( a11, a21, a31, a12, a22, a32, a13, a23, a33)
{
	this.a11 = a11;
	this.a12 = a12;
	this.a13 = a13;
	this.a21 = a21;
	this.a22 = a22;
	this.a23 = a23;
	this.a31 = a31;
	this.a32 = a32;
	this.a33 = a33;
	this.transformPoints1=function( points)
		{
			var max = points.length;
			var a11 = this.a11;
			var a12 = this.a12;
			var a13 = this.a13;
			var a21 = this.a21;
			var a22 = this.a22;
			var a23 = this.a23;
			var a31 = this.a31;
			var a32 = this.a32;
			var a33 = this.a33;
			for (var i = 0; i &#x3c; max; i += 2)
			{
				var x = points[i];
				var y = points[i + 1];
				var denominator = a13 * x + a23 * y + a33;
				points[i] = (a11 * x + a21 * y + a31) / denominator;
				points[i + 1] = (a12 * x + a22 * y + a32) / denominator;
			}
		}
	this. transformPoints2=function(xValues, yValues)
		{
			var n = xValues.length;
			for (var i = 0; i &#x3c; n; i++)
			{
				var x = xValues[i];
				var y = yValues[i];
				var denominator = this.a13 * x + this.a23 * y + this.a33;
				xValues[i] = (this.a11 * x + this.a21 * y + this.a31) / denominator;
				yValues[i] = (this.a12 * x + this.a22 * y + this.a32) / denominator;
			}
		}

	this.buildAdjoint=function()
		{
			// Adjoint is the transpose of the cofactor matrix:
			return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21
 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12
 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11
 * this.a22 - this.a12 * this.a21);
		}
	this.times=function( other)
		{
			return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this
.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11
 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other
.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 +this.a33 * other.a13, this.a13 *
other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
		}

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.rsdecoder" id="apidoc.element.jsqrcode.rsdecoder">
        function <span class="apidocSignatureSpan">jsqrcode.</span>rsdecoder
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReedSolomonDecoder(field)
{
  this.field = field;
  this.decode=function(received,  twoS)
  {
      var poly = new GF256Poly(this.field, received);
      var syndromeCoefficients = new Array(twoS);
      for(var i=0;i&#x3c;syndromeCoefficients.length;i++)syndromeCoefficients[i]=0;
      var dataMatrix = false;//this.field.Equals(GF256.DATA_MATRIX_FIELD);
      var noError = true;
      for (var i = 0; i &#x3c; twoS; i++)
      {
        // Thanks to sanfordsquires for this fix:
        var eval = poly.evaluateAt(this.field.exp(dataMatrix?i + 1:i));
        syndromeCoefficients[syndromeCoefficients.length - 1 - i] = eval;
        if (eval != 0)
        {
          noError = false;
        }
      }
      if (noError)
      {
        return ;
      }
      var syndrome = new GF256Poly(this.field, syndromeCoefficients);
      var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(twoS, 1), syndrome, twoS);
      var sigma = sigmaOmega[0];
      var omega = sigmaOmega[1];
      var errorLocations = this.findErrorLocations(sigma);
      var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations, dataMatrix);
      for (var i = 0; i &#x3c; errorLocations.length; i++)
      {
        var position = received.length - 1 - this.field.log(errorLocations[i]);
        if (position &#x3c; 0)
        {
          throw &#x22;ReedSolomonException Bad error location&#x22;;
        }
        received[position] = GF256.addOrSubtract(received[position], errorMagnitudes[i]);
      }
  }

  this.runEuclideanAlgorithm=function( a,  b,  R)
    {
      // Assume a&#x27;s degree is &#x3e;= b&#x27;s
      if (a.Degree &#x3c; b.Degree)
      {
        var temp = a;
        a = b;
        b = temp;
      }

      var rLast = a;
      var r = b;
      var sLast = this.field.One;
      var s = this.field.Zero;
      var tLast = this.field.Zero;
      var t = this.field.One;

      // Run Euclidean algorithm until r&#x27;s degree is less than R/2
      while (r.Degree &#x3e;= Math.floor(R / 2))
      {
        var rLastLast = rLast;
        var sLastLast = sLast;
        var tLastLast = tLast;
        rLast = r;
        sLast = s;
        tLast = t;

        // Divide rLastLast by rLast, with quotient in q and remainder in r
        if (rLast.Zero)
        {
          // Oops, Euclidean algorithm already terminated?
          throw &#x22;r_{i-1} was zero&#x22;;
        }
        r = rLastLast;
        var q = this.field.Zero;
        var denominatorLeadingTerm = rLast.getCoefficient(rLast.Degree);
        var dltInverse = this.field.inverse(denominatorLeadingTerm);
        while (r.Degree &#x3e;= rLast.Degree &#x26;&#x26; !r.Zero)
        {
          var degreeDiff = r.Degree - rLast.Degree;
          var scale = this.field.multiply(r.getCoefficient(r.Degree), dltInverse);
          q = q.addOrSubtract(this.field.buildMonomial(degreeDiff, scale));
          r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
          //r.EXE();
        }

        s = q.multiply1(sLast).addOrSubtract(sLastLast);
        t = q.multiply1(tLast).addOrSubtract(tLastLast);
      }

      var sigmaTildeAtZero = t.getCoefficient(0);
      if (sigmaTildeAtZero == 0)
      {
        throw &#x22;ReedSolomonException sigmaTilde(0) was zero&#x22;;
      }

      var inverse = this.field.inverse(sigmaTildeAtZero);
      var sigma = t.multiply2(inverse);
      var omega = r.multiply2(inverse);
      return new Array(sigma, omega);
    }
  this.findErrorLocations=function( errorLocator)
    {
      // This is a direct application of Chien&#x27;s search
      var numErrors = errorLocator.Degree;
      if (numErrors == 1)
      {
        // shortcut
        return new Array(errorLocator.getCoefficient(1));
      }
      var result = new Array(numErrors);
      var e = 0;
      for (var i = 1; i &#x3c; 256 &#x26;&#x26; e &#x3c; numErrors; i++)
      {
        if (errorLocator.evaluateAt(i) == 0)
        {
          result[e] = this.field.inverse(i);
          e++;
        }
      }
      if (e != nu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.toString" id="apidoc.element.jsqrcode.toString">
        function <span class="apidocSignatureSpan">jsqrcode.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.version" id="apidoc.element.jsqrcode.version">
        function <span class="apidocSignatureSpan">jsqrcode.</span>version
        <span class="apidocSignatureSpan">( versionNumber, alignmentPatternCenters, ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Version( versionNumber, alignmentPatternCenters, ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4)
{
  this.versionNumber = versionNumber;
  this.alignmentPatternCenters = alignmentPatternCenters;
  this.ecBlocks = new Array(ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4);

  var total = 0;
  var ecCodewords = ecBlocks1.ECCodewordsPerBlock;
  var ecbArray = ecBlocks1.getECBlocks();
  for (var i = 0; i &#x3c; ecbArray.length; i++)
  {
    var ecBlock = ecbArray[i];
    total += ecBlock.Count * (ecBlock.DataCodewords + ecCodewords);
  }
  this.totalCodewords = total;

  this.__defineGetter__(&#x22;VersionNumber&#x22;, function()
  {
    return  this.versionNumber;
  });

  this.__defineGetter__(&#x22;AlignmentPatternCenters&#x22;, function()
  {
    return  this.alignmentPatternCenters;
  });
  this.__defineGetter__(&#x22;TotalCodewords&#x22;, function()
  {
    return  this.totalCodewords;
  });
  this.__defineGetter__(&#x22;DimensionForVersion&#x22;, function()
  {
    return  17 + 4 * this.versionNumber;
  });

  this.buildFunctionPattern=function()
    {
      var dimension = this.DimensionForVersion;
      var bitMatrix = new BitMatrix(dimension);

      // Top left finder pattern + separator + format
      bitMatrix.setRegion(0, 0, 9, 9);
      // Top right finder pattern + separator + format
      bitMatrix.setRegion(dimension - 8, 0, 8, 9);
      // Bottom left finder pattern + separator + format
      bitMatrix.setRegion(0, dimension - 8, 9, 8);

      // Alignment patterns
      var max = this.alignmentPatternCenters.length;
      for (var x = 0; x &#x3c; max; x++)
      {
        var i = this.alignmentPatternCenters[x] - 2;
        for (var y = 0; y &#x3c; max; y++)
        {
          if ((x == 0 &#x26;&#x26; (y == 0 || y == max - 1)) || (x == max - 1 &#x26;&#x26; y == 0))
          {
            // No alignment patterns near the three finder paterns
            continue;
          }
          bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);
        }
      }

      // Vertical timing pattern
      bitMatrix.setRegion(6, 9, 1, dimension - 17);
      // Horizontal timing pattern
      bitMatrix.setRegion(9, 6, dimension - 17, 1);

      if (this.versionNumber &#x3e; 6)
      {
        // Version info, top right
        bitMatrix.setRegion(dimension - 11, 0, 3, 6);
        // Version info, bottom left
        bitMatrix.setRegion(0, dimension - 11, 6, 3);
      }

      return bitMatrix;
    }
  this.getECBlocksForLevel=function( ecLevel)
  {
    return this.ecBlocks[ecLevel.ordinal()];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.alignpat" id="apidoc.module.jsqrcode.alignpat">module jsqrcode.alignpat</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.alignpat.alignpat" id="apidoc.element.jsqrcode.alignpat.alignpat">
        function <span class="apidocSignatureSpan">jsqrcode.</span>alignpat
        <span class="apidocSignatureSpan">( image, startX, startY, width, height, moduleSize, resultPointCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AlignmentPatternFinder( image, startX, startY, width, height, moduleSize, resultPointCallback)
{
  this.image = image;
  this.possibleCenters = new Array();
  this.startX = startX;
  this.startY = startY;
  this.width = width;
  this.height = height;
  this.moduleSize = moduleSize;
  this.crossCheckStateCount = new Array(0,0,0);
  this.resultPointCallback = resultPointCallback;

  this.centerFromEnd=function(stateCount,  end)
    {
      return  (end - stateCount[2]) - stateCount[1] / 2.0;
    }
  this.foundPatternCross = function(stateCount)
    {
      var moduleSize = this.moduleSize;
      var maxVariance = moduleSize / 2.0;
      for (var i = 0; i &#x3c; 3; i++)
      {
        if (Math.abs(moduleSize - stateCount[i]) &#x3e;= maxVariance)
        {
          return false;
        }
      }
      return true;
    }

  this.crossCheckVertical=function( startI,  centerJ,  maxCount,  originalStateCountTotal)
    {
      var image = this.image;

      var maxI = qrcode.height;
      var stateCount = this.crossCheckStateCount;
      stateCount[0] = 0;
      stateCount[1] = 0;
      stateCount[2] = 0;

      // Start counting up from center
      var i = startI;
      while (i &#x3e;= 0 &#x26;&#x26; image[centerJ + i*qrcode.width] &#x26;&#x26; stateCount[1] &#x3c;= maxCount)
      {
        stateCount[1]++;
        i--;
      }
      // If already too many modules in this state or ran off the edge:
      if (i &#x3c; 0 || stateCount[1] &#x3e; maxCount)
      {
        return NaN;
      }
      while (i &#x3e;= 0 &#x26;&#x26; !image[centerJ + i*qrcode.width] &#x26;&#x26; stateCount[0] &#x3c;= maxCount)
      {
        stateCount[0]++;
        i--;
      }
      if (stateCount[0] &#x3e; maxCount)
      {
        return NaN;
      }

      // Now also count down from center
      i = startI + 1;
      while (i &#x3c; maxI &#x26;&#x26; image[centerJ + i*qrcode.width] &#x26;&#x26; stateCount[1] &#x3c;= maxCount)
      {
        stateCount[1]++;
        i++;
      }
      if (i == maxI || stateCount[1] &#x3e; maxCount)
      {
        return NaN;
      }
      while (i &#x3c; maxI &#x26;&#x26; !image[centerJ + i*qrcode.width] &#x26;&#x26; stateCount[2] &#x3c;= maxCount)
      {
        stateCount[2]++;
        i++;
      }
      if (stateCount[2] &#x3e; maxCount)
      {
        return NaN;
      }

      var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
      if (5 * Math.abs(stateCountTotal - originalStateCountTotal) &#x3e;= 2 * originalStateCountTotal)
      {
        return NaN;
      }

      return this.foundPatternCross(stateCount)?this.centerFromEnd(stateCount, i):NaN;
    }

  this.handlePossibleCenter=function( stateCount,  i,  j)
    {
      var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
      var centerJ = this.centerFromEnd(stateCount, j);
      var centerI = this.crossCheckVertical(i, Math.floor (centerJ), 2 * stateCount[1], stateCountTotal);
      if (!isNaN(centerI))
      {
        var estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;
        var max = this.possibleCenters.length;
        for (var index = 0; index &#x3c; max; index++)
        {
          var center =  this.possibleCenters[index];
          // Look for about the same center and module size:
          if (center.aboutEquals(estimatedModuleSize, centerI, centerJ))
          {
            return new AlignmentPattern(centerJ, centerI, estimatedModuleSize);
          }
        }
        // Hadn&#x27;t found this before; save it
        var point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);
        this.possibleCenters.push(point);
        if (this.resultPointCallback != null)
        {
          this.resultPointCallback.foundPossibleResultPoint(point);
        }
      }
      return null;
    }

  this.find = function()
  {
      var startX = this.startX;
      var height = this.height;
      var maxJ = startX + width;
      var middleI = startY + (height &#x3e;&#x3e; 1);
      // We are looking for black/white/black modules in 1:1:1 ratio;
      // this tracks th ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.bitmat" id="apidoc.module.jsqrcode.bitmat">module jsqrcode.bitmat</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.bitmat.bitmat" id="apidoc.element.jsqrcode.bitmat.bitmat">
        function <span class="apidocSignatureSpan">jsqrcode.</span>bitmat
        <span class="apidocSignatureSpan">( width, height)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BitMatrix( width, height) {
  if(!height)
    height=width;
  if (width &#x3c; 1 || height &#x3c; 1)
  {
    throw &#x22;Both dimensions must be greater than 0&#x22;;
  }
  this.width = width;
  this.height = height;
  var rowSize = width &#x3e;&#x3e; 5;
  if ((width &#x26; 0x1f) != 0)
  {
    rowSize++;
  }
  this.rowSize = rowSize;
  this.bits = new Array(rowSize * height);
  for(var i=0;i&#x3c;this.bits.length;i++)
    this.bits[i]=0;

  this.__defineGetter__(&#x22;Width&#x22;, function()
  {
    return this.width;
  });
  this.__defineGetter__(&#x22;Height&#x22;, function()
  {
    return this.height;
  });
  this.__defineGetter__(&#x22;Dimension&#x22;, function()
  {
    if (this.width != this.height)
    {
      throw &#x22;Can&#x27;t call getDimension() on a non-square matrix&#x22;;
    }
    return this.width;
  });

  this.get_Renamed=function( x,  y)
    {
      var offset = y * this.rowSize + (x &#x3e;&#x3e; 5);
      return ((qrcode.URShift(this.bits[offset], (x &#x26; 0x1f))) &#x26; 1) != 0;
    }
  this.set_Renamed=function( x,  y)
    {
      var offset = y * this.rowSize + (x &#x3e;&#x3e; 5);
      this.bits[offset] |= 1 &#x3c;&#x3c; (x &#x26; 0x1f);
    }
  this.flip=function( x,  y)
    {
      var offset = y * this.rowSize + (x &#x3e;&#x3e; 5);
      this.bits[offset] ^= 1 &#x3c;&#x3c; (x &#x26; 0x1f);
    }
  this.clear=function()
    {
      var max = this.bits.length;
      for (var i = 0; i &#x3c; max; i++)
      {
        this.bits[i] = 0;
      }
    }
  this.setRegion=function( left,  top,  width,  height)
    {
      if (top &#x3c; 0 || left &#x3c; 0)
      {
        throw &#x22;Left and top must be nonnegative&#x22;;
      }
      if (height &#x3c; 1 || width &#x3c; 1)
      {
        throw &#x22;Height and width must be at least 1&#x22;;
      }
      var right = left + width;
      var bottom = top + height;
      if (bottom &#x3e; this.height || right &#x3e; this.width)
      {
        throw &#x22;The region must fit inside the matrix&#x22;;
      }
      for (var y = top; y &#x3c; bottom; y++)
      {
        var offset = y * this.rowSize;
        for (var x = left; x &#x3c; right; x++)
        {
          this.bits[offset + (x &#x3e;&#x3e; 5)] |= 1 &#x3c;&#x3c; (x &#x26; 0x1f);
        }
      }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.bmparser" id="apidoc.module.jsqrcode.bmparser">module jsqrcode.bmparser</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.bmparser.bmparser" id="apidoc.element.jsqrcode.bmparser.bmparser">
        function <span class="apidocSignatureSpan">jsqrcode.</span>bmparser
        <span class="apidocSignatureSpan">(bitMatrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BitMatrixParser(bitMatrix)
{
  var dimension = bitMatrix.Dimension;
  if (dimension &#x3c; 21 || (dimension &#x26; 0x03) != 1)
  {
    throw &#x22;Error BitMatrixParser&#x22;;
  }
  this.bitMatrix = bitMatrix;
  this.parsedVersion = null;
  this.parsedFormatInfo = null;

  this.copyBit=function( i,  j,  versionBits)
  {
    return this.bitMatrix.get_Renamed(i, j)?(versionBits &#x3c;&#x3c; 1) | 0x1:versionBits &#x3c;&#x3c; 1;
  }

  this.readFormatInformation=function()
  {
      if (this.parsedFormatInfo != null)
      {
        return this.parsedFormatInfo;
      }

      // Read top-left format info bits
      var formatInfoBits = 0;
      for (var i = 0; i &#x3c; 6; i++)
      {
        formatInfoBits = this.copyBit(i, 8, formatInfoBits);
      }
      // .. and skip a bit in the timing pattern ...
      formatInfoBits = this.copyBit(7, 8, formatInfoBits);
      formatInfoBits = this.copyBit(8, 8, formatInfoBits);
      formatInfoBits = this.copyBit(8, 7, formatInfoBits);
      // .. and skip a bit in the timing pattern ...
      for (var j = 5; j &#x3e;= 0; j--)
      {
        formatInfoBits = this.copyBit(8, j, formatInfoBits);
      }

      this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits);
      if (this.parsedFormatInfo != null)
      {
        return this.parsedFormatInfo;
      }

      // Hmm, failed. Try the top-right/bottom-left pattern
      var dimension = this.bitMatrix.Dimension;
      formatInfoBits = 0;
      var iMin = dimension - 8;
      for (var i = dimension - 1; i &#x3e;= iMin; i--)
      {
        formatInfoBits = this.copyBit(i, 8, formatInfoBits);
      }
      for (var j = dimension - 7; j &#x3c; dimension; j++)
      {
        formatInfoBits = this.copyBit(8, j, formatInfoBits);
      }

      this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits);
      if (this.parsedFormatInfo != null)
      {
        return this.parsedFormatInfo;
      }
      throw &#x22;Error readFormatInformation&#x22;;
  }
  this.readVersion=function()
    {

      if (this.parsedVersion != null)
      {
        return this.parsedVersion;
      }

      var dimension = this.bitMatrix.Dimension;

      var provisionalVersion = (dimension - 17) &#x3e;&#x3e; 2;
      if (provisionalVersion &#x3c;= 6)
      {
        return Version.getVersionForNumber(provisionalVersion);
      }

      // Read top-right version info: 3 wide by 6 tall
      var versionBits = 0;
      var ijMin = dimension - 11;
      for (var j = 5; j &#x3e;= 0; j--)
      {
        for (var i = dimension - 9; i &#x3e;= ijMin; i--)
        {
          versionBits = this.copyBit(i, j, versionBits);
        }
      }

      this.parsedVersion = Version.decodeVersionInformation(versionBits);
      if (this.parsedVersion != null &#x26;&#x26; this.parsedVersion.DimensionForVersion == dimension)
      {
        return this.parsedVersion;
      }

      // Hmm, failed. Try bottom left: 6 wide by 3 tall
      versionBits = 0;
      for (var i = 5; i &#x3e;= 0; i--)
      {
        for (var j = dimension - 9; j &#x3e;= ijMin; j--)
        {
          versionBits = this.copyBit(i, j, versionBits);
        }
      }

      this.parsedVersion = Version.decodeVersionInformation(versionBits);
      if (this.parsedVersion != null &#x26;&#x26; this.parsedVersion.DimensionForVersion == dimension)
      {
        return this.parsedVersion;
      }
      throw &#x22;Error readVersion&#x22;;
    }
  this.readCodewords=function()
    {

      var formatInfo = this.readFormatInformation();
      var version = this.readVersion();

      // Get the data mask for the format used in this QR Code. This will exclude
      // some bits from reading as we wind through the bit matrix.
      var dataMask = DataMask.forReference( formatInfo.DataMask);
      var dimension = this.bitMatrix.Dimension;
      dataMask.unmaskBitMatrix(this.bitMatrix, dimension);

      var functionPattern = version.buildFunctionPattern();

      var re ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.datablock" id="apidoc.module.jsqrcode.datablock">module jsqrcode.datablock</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.datablock.datablock" id="apidoc.element.jsqrcode.datablock.datablock">
        function <span class="apidocSignatureSpan">jsqrcode.</span>datablock
        <span class="apidocSignatureSpan">(numDataCodewords, codewords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataBlock(numDataCodewords, codewords)
{
	this.numDataCodewords = numDataCodewords;
	this.codewords = codewords;
	
	this.__defineGetter__(&#x22;NumDataCodewords&#x22;, function()
	{
		return this.numDataCodewords;
	});
	this.__defineGetter__(&#x22;Codewords&#x22;, function()
	{
		return this.codewords;
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.datablock.getDataBlocks" id="apidoc.element.jsqrcode.datablock.getDataBlocks">
        function <span class="apidocSignatureSpan">jsqrcode.datablock.</span>getDataBlocks
        <span class="apidocSignatureSpan">(rawCodewords, version, ecLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataBlocks = function (rawCodewords, version, ecLevel)
{
	
	if (rawCodewords.length != version.TotalCodewords)
	{
		throw &#x22;ArgumentException&#x22;;
	}
	
	// Figure out the number and size of data blocks used by this version and
	// error correction level
	var ecBlocks = version.getECBlocksForLevel(ecLevel);
	
	// First count the total number of data blocks
	var totalBlocks = 0;
	var ecBlockArray = ecBlocks.getECBlocks();
	for (var i = 0; i &#x3c; ecBlockArray.length; i++)
	{
		totalBlocks += ecBlockArray[i].Count;
	}
	
	// Now establish DataBlocks of the appropriate size and number of data codewords
	var result = new Array(totalBlocks);
	var numResultBlocks = 0;
	for (var j = 0; j &#x3c; ecBlockArray.length; j++)
	{
		var ecBlock = ecBlockArray[j];
		for (var i = 0; i &#x3c; ecBlock.Count; i++)
		{
			var numDataCodewords = ecBlock.DataCodewords;
			var numBlockCodewords = ecBlocks.ECCodewordsPerBlock + numDataCodewords;
			result[numResultBlocks++] = new DataBlock(numDataCodewords, new Array(numBlockCodewords));
		}
	}
	
	// All blocks have the same amount of data, except that the last n
	// (where n may be 0) have 1 more byte. Figure out where these start.
	var shorterBlocksTotalCodewords = result[0].codewords.length;
	var longerBlocksStartAt = result.length - 1;
	while (longerBlocksStartAt &#x3e;= 0)
	{
		var numCodewords = result[longerBlocksStartAt].codewords.length;
		if (numCodewords == shorterBlocksTotalCodewords)
		{
			break;
		}
		longerBlocksStartAt--;
	}
	longerBlocksStartAt++;
	
	var shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.ECCodewordsPerBlock;
	// The last elements of result may be 1 element longer;
	// first fill out as many elements as all of them have
	var rawCodewordsOffset = 0;
	for (var i = 0; i &#x3c; shorterBlocksNumDataCodewords; i++)
	{
		for (var j = 0; j &#x3c; numResultBlocks; j++)
		{
			result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
		}
	}
	// Fill out the last data block in the longer ones
	for (var j = longerBlocksStartAt; j &#x3c; numResultBlocks; j++)
	{
		result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];
	}
	// Now add in error correction blocks
	var max = result[0].codewords.length;
	for (var i = shorterBlocksNumDataCodewords; i &#x3c; max; i++)
	{
		for (var j = 0; j &#x3c; numResultBlocks; j++)
		{
			var iOffset = j &#x3c; longerBlocksStartAt?i:i + 1;
			result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
		}
	}
	return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var version = parser.readVersion();
var ecLevel = parser.readFormatInformation().ErrorCorrectionLevel;

// Read codewords
var codewords = parser.readCodewords();

// Separate into data blocks
var dataBlocks = DataBlock.<span class="apidocCodeKeywordSpan">getDataBlocks</span>(codewords, version, ecLevel);

// Count total number of data bytes
var totalBytes = 0;
for (var i = 0; i &#x3c; dataBlocks.Length; i++)
{
  totalBytes += dataBlocks[i].NumDataCodewords;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.databr" id="apidoc.module.jsqrcode.databr">module jsqrcode.databr</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.databr.databr" id="apidoc.element.jsqrcode.databr.databr">
        function <span class="apidocSignatureSpan">jsqrcode.</span>databr
        <span class="apidocSignatureSpan">(blocks, version, numErrorCorrectionCode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QRCodeDataBlockReader(blocks, version, numErrorCorrectionCode)
{
  this.blockPointer = 0;
  this.bitPointer = 7;
  this.dataLength = 0;
  this.blocks = blocks;
  this.numErrorCorrectionCode = numErrorCorrectionCode;
  if (version &#x3c;= 9)
    this.dataLengthMode = 0;
  else if (version &#x3e;= 10 &#x26;&#x26; version &#x3c;= 26)
    this.dataLengthMode = 1;
  else if (version &#x3e;= 27 &#x26;&#x26; version &#x3c;= 40)
    this.dataLengthMode = 2;

  this.getNextBits = function( numBits)
    {
      var bits = 0;
      if (numBits &#x3c; this.bitPointer + 1)
      {
        // next word fits into current data block
        var mask = 0;
        for (var i = 0; i &#x3c; numBits; i++)
        {
          mask += (1 &#x3c;&#x3c; i);
        }
        mask &#x3c;&#x3c;= (this.bitPointer - numBits + 1);

        bits = (this.blocks[this.blockPointer] &#x26; mask) &#x3e;&#x3e; (this.bitPointer - numBits + 1);
        this.bitPointer -= numBits;
        return bits;
      }
      else if (numBits &#x3c; this.bitPointer + 1 + 8)
      {
        // next word crosses 2 data blocks
        var mask1 = 0;
        for (var i = 0; i &#x3c; this.bitPointer + 1; i++)
        {
          mask1 += (1 &#x3c;&#x3c; i);
        }
        bits = (this.blocks[this.blockPointer] &#x26; mask1) &#x3c;&#x3c; (numBits - (this.bitPointer + 1));
                this.blockPointer++;
        bits += ((this.blocks[this.blockPointer]) &#x3e;&#x3e; (8 - (numBits - (this.bitPointer + 1))));

        this.bitPointer = this.bitPointer - numBits % 8;
        if (this.bitPointer &#x3c; 0)
        {
          this.bitPointer = 8 + this.bitPointer;
        }
        return bits;
      }
      else if (numBits &#x3c; this.bitPointer + 1 + 16)
      {
        // next word crosses 3 data blocks
        var mask1 = 0; // mask of first block
        var mask3 = 0; // mask of 3rd block
        //bitPointer + 1 : number of bits of the 1st block
        //8 : number of the 2nd block (note that use already 8bits because next word uses 3 data blocks)
        //numBits - (bitPointer + 1 + 8) : number of bits of the 3rd block
        for (var i = 0; i &#x3c; this.bitPointer + 1; i++)
        {
          mask1 += (1 &#x3c;&#x3c; i);
        }
        var bitsFirstBlock = (this.blocks[this.blockPointer] &#x26; mask1) &#x3c;&#x3c; (numBits - (this.bitPointer + 1));
        this.blockPointer++;

        var bitsSecondBlock = this.blocks[this.blockPointer] &#x3c;&#x3c; (numBits - (this.bitPointer + 1 + 8));
        this.blockPointer++;

        for (var i = 0; i &#x3c; numBits - (this.bitPointer + 1 + 8); i++)
        {
          mask3 += (1 &#x3c;&#x3c; i);
        }
        mask3 &#x3c;&#x3c;= 8 - (numBits - (this.bitPointer + 1 + 8));
        var bitsThirdBlock = (this.blocks[this.blockPointer] &#x26; mask3) &#x3e;&#x3e; (8 - (numBits - (this.bitPointer + 1 + 8)));

        bits = bitsFirstBlock + bitsSecondBlock + bitsThirdBlock;
        this.bitPointer = this.bitPointer - (numBits - 8) % 8;
        if (this.bitPointer &#x3c; 0)
        {
          this.bitPointer = 8 + this.bitPointer;
        }
        return bits;
      }
      else
      {
        return 0;
      }
    }
  this.NextMode=function()
  {
    if ((this.blockPointer &#x3e; this.blocks.length - this.numErrorCorrectionCode - 2))
      return 0;
    else
      return this.getNextBits(4);
  }
  this.getDataLength=function( modeIndicator)
    {
      var index = 0;
      while (true)
      {
        if ((modeIndicator &#x3e;&#x3e; index) == 1)
          break;
        index++;
      }

      return this.getNextBits(qrcode.sizeOfDataLengthInfo[this.dataLengthMode][index]);
    }
  this.getRomanAndFigureString=function( dataLength)
    {
      var length = dataLength;
      var intData = 0;
      var strData = &#x22;&#x22;;
      var tableRomanAndFigure = new Array(&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;
H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27; &#x27;, &#x27;$&#x27;, &#x27;%&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;-&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, &#x27;:&#x27;);
      do
      {
        if (length &#x3e; 1)
        {
          intData = this.getNextBits(11); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.datamask" id="apidoc.module.jsqrcode.datamask">module jsqrcode.datamask</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.datamask.forReference" id="apidoc.element.jsqrcode.datamask.forReference">
        function <span class="apidocSignatureSpan">jsqrcode.datamask.</span>forReference
        <span class="apidocSignatureSpan">(reference)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forReference = function (reference)
{
  if (reference &#x3c; 0 || reference &#x3e; 7)
  {
    throw &#x22;System.ArgumentException&#x22;;
  }
  return DataMask.DATA_MASKS[reference];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    {

var formatInfo = this.readFormatInformation();
var version = this.readVersion();

// Get the data mask for the format used in this QR Code. This will exclude
// some bits from reading as we wind through the bit matrix.
var dataMask = DataMask.<span class="apidocCodeKeywordSpan">forReference</span>( formatInfo.DataMask);
var dimension = this.bitMatrix.Dimension;
dataMask.unmaskBitMatrix(this.bitMatrix, dimension);

var functionPattern = version.buildFunctionPattern();

var readingUp = true;
var result = new Array(version.TotalCodewords);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.decoder" id="apidoc.module.jsqrcode.decoder">module jsqrcode.decoder</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.decoder.correctErrors" id="apidoc.element.jsqrcode.decoder.correctErrors">
        function <span class="apidocSignatureSpan">jsqrcode.decoder.</span>correctErrors
        <span class="apidocSignatureSpan">( codewordBytes, numDataCodewords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">correctErrors = function ( codewordBytes, numDataCodewords)
{
  var numCodewords = codewordBytes.length;
  // First read into an array of ints
  var codewordsInts = new Array(numCodewords);
  for (var i = 0; i &#x3c; numCodewords; i++)
  {
    codewordsInts[i] = codewordBytes[i] &#x26; 0xFF;
  }
  var numECCodewords = codewordBytes.length - numDataCodewords;
  try
  {
    Decoder.rsDecoder.decode(codewordsInts, numECCodewords);
    //var corrector = new ReedSolomon(codewordsInts, numECCodewords);
    //corrector.correct();
  }
  catch ( rse)
  {
    throw rse;
  }
  // Copy back into array of bytes -- only need to worry about the bytes that were data
  // We don&#x27;t care about errors in the error-correction codewords
  for (var i = 0; i &#x3c; numDataCodewords; i++)
  {
    codewordBytes[i] =  codewordsInts[i];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Error-correct and copy data blocks together into a stream of bytes
for (var j = 0; j &#x3c; dataBlocks.length; j++)
{
  var dataBlock = dataBlocks[j];
  var codewordBytes = dataBlock.Codewords;
  var numDataCodewords = dataBlock.NumDataCodewords;
  Decoder.<span class="apidocCodeKeywordSpan">correctErrors</span>(codewordBytes, numDataCodewords);
  for (var i = 0; i &#x3c; numDataCodewords; i++)
  {
    resultBytes[resultOffset++] = codewordBytes[i];
  }
}

// Decode the contents of that stream of bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.decoder.decode" id="apidoc.element.jsqrcode.decoder.decode">
        function <span class="apidocSignatureSpan">jsqrcode.decoder.</span>decode
        <span class="apidocSignatureSpan">(bits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (bits)
{
  var parser = new BitMatrixParser(bits);
  var version = parser.readVersion();
  var ecLevel = parser.readFormatInformation().ErrorCorrectionLevel;

  // Read codewords
  var codewords = parser.readCodewords();

  // Separate into data blocks
  var dataBlocks = DataBlock.getDataBlocks(codewords, version, ecLevel);

  // Count total number of data bytes
  var totalBytes = 0;
  for (var i = 0; i &#x3c; dataBlocks.Length; i++)
  {
    totalBytes += dataBlocks[i].NumDataCodewords;
  }
  var resultBytes = new Array(totalBytes);
  var resultOffset = 0;

  // Error-correct and copy data blocks together into a stream of bytes
  for (var j = 0; j &#x3c; dataBlocks.length; j++)
  {
    var dataBlock = dataBlocks[j];
    var codewordBytes = dataBlock.Codewords;
    var numDataCodewords = dataBlock.NumDataCodewords;
    Decoder.correctErrors(codewordBytes, numDataCodewords);
    for (var i = 0; i &#x3c; numDataCodewords; i++)
    {
      resultBytes[resultOffset++] = codewordBytes[i];
    }
  }

  // Decode the contents of that stream of bytes
  var reader = new QRCodeDataBlockReader(resultBytes, version.VersionNumber, ecLevel.Bits);
  return reader;
  //return DecodedBitStreamParser.decode(resultBytes, version, ecLevel);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    var filename = __dirname + &#x27;/qrcode.png&#x27;

    var image = new Image()
    image.onload = function(){
      var result;
      try{
        result = qrcode.<span class="apidocCodeKeywordSpan">decode</span>(image);
        console.log(&#x27;result of qr code: &#x27; + result);
      }catch(e){
        console.log(&#x27;unable to read qr code&#x27;);
      }
    }
    image.src = filename
````
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.detector" id="apidoc.module.jsqrcode.detector">module jsqrcode.detector</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.detector.detector" id="apidoc.element.jsqrcode.detector.detector">
        function <span class="apidocSignatureSpan">jsqrcode.</span>detector
        <span class="apidocSignatureSpan">(image)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Detector(image)
{
  this.image=image;
  this.resultPointCallback = null;

  this.sizeOfBlackWhiteBlackRun=function( fromX,  fromY,  toX,  toY)
    {
      // Mild variant of Bresenham&#x27;s algorithm;
      // see http://en.wikipedia.org/wiki/Bresenham&#x27;s_line_algorithm
      var steep = Math.abs(toY - fromY) &#x3e; Math.abs(toX - fromX);
      if (steep)
      {
        var temp = fromX;
        fromX = fromY;
        fromY = temp;
        temp = toX;
        toX = toY;
        toY = temp;
      }

      var dx = Math.abs(toX - fromX);
      var dy = Math.abs(toY - fromY);
      var error = - dx &#x3e;&#x3e; 1;
      var ystep = fromY &#x3c; toY?1:- 1;
      var xstep = fromX &#x3c; toX?1:- 1;
      var state = 0; // In black pixels, looking for white, first or second time
      for (var x = fromX, y = fromY; x != toX; x += xstep)
      {

        var realX = steep?y:x;
        var realY = steep?x:y;
        if (state == 1)
        {
          // In white pixels, looking for black
          if (this.image[realX + realY*qrcode.width])
          {
            state++;
          }
        }
        else
        {
          if (!this.image[realX + realY*qrcode.width])
          {
            state++;
          }
        }

        if (state == 3)
        {
          // Found black, white, black, and stumbled back onto white; done
          var diffX = x - fromX;
          var diffY = y - fromY;
          return  Math.sqrt( (diffX * diffX + diffY * diffY));
        }
        error += dy;
        if (error &#x3e; 0)
        {
          if (y == toY)
          {
            break;
          }
          y += ystep;
          error -= dx;
        }
      }
      var diffX2 = toX - fromX;
      var diffY2 = toY - fromY;
      return  Math.sqrt( (diffX2 * diffX2 + diffY2 * diffY2));
    }


  this.sizeOfBlackWhiteBlackRunBothWays=function( fromX,  fromY,  toX,  toY)
    {

      var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);

      // Now count other way -- don&#x27;t run off image though of course
      var scale = 1.0;
      var otherToX = fromX - (toX - fromX);
      if (otherToX &#x3c; 0)
      {
        scale =  fromX /  (fromX - otherToX);
        otherToX = 0;
      }
      else if (otherToX &#x3e;= qrcode.width)
      {
        scale =  (qrcode.width - 1 - fromX) /  (otherToX - fromX);
        otherToX = qrcode.width - 1;
      }
      var otherToY = Math.floor (fromY - (toY - fromY) * scale);

      scale = 1.0;
      if (otherToY &#x3c; 0)
      {
        scale =  fromY /  (fromY - otherToY);
        otherToY = 0;
      }
      else if (otherToY &#x3e;= qrcode.height)
      {
        scale =  (qrcode.height - 1 - fromY) /  (otherToY - fromY);
        otherToY = qrcode.height - 1;
      }
      otherToX = Math.floor (fromX + (otherToX - fromX) * scale);

      result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
      return result - 1.0; // -1 because we counted the middle pixel twice
    }



  this.calculateModuleSizeOneWay=function( pattern,  otherPattern)
    {
      var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor( pattern.X), Math.floor( pattern.Y), Math.floor( otherPattern
.X), Math.floor(otherPattern.Y));
      var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(otherPattern.X), Math.floor(otherPattern.Y), Math.floor
( pattern.X), Math.floor(pattern.Y));
      if (isNaN(moduleSizeEst1))
      {
        return moduleSizeEst2 / 7.0;
      }
      if (isNaN(moduleSizeEst2))
      {
        return moduleSizeEst1 / 7.0;
      }
      // Average them, and divide by 7 since we&#x27;ve counted the width of 3 black modules,
      // and 1 white and 1 black module on either side. Ergo, divide sum by 14.
      return (moduleSizeEst1 + moduleSizeEst2) / 14.0;
    }


  this.calculateModuleSize=function( topLeft,  topRight,  bottomLeft)
    {
      // Take the average
      return (this.calculateModuleSizeOneWay(topL ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.errorlevel" id="apidoc.module.jsqrcode.errorlevel">module jsqrcode.errorlevel</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.errorlevel.errorlevel" id="apidoc.element.jsqrcode.errorlevel.errorlevel">
        function <span class="apidocSignatureSpan">jsqrcode.</span>errorlevel
        <span class="apidocSignatureSpan">(ordinal, bits, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ErrorCorrectionLevel(ordinal, bits, name)
{
	this.ordinal_Renamed_Field = ordinal;
	this.bits = bits;
	this.name = name;
	this.__defineGetter__(&#x22;Bits&#x22;, function()
	{
		return this.bits;
	});
	this.__defineGetter__(&#x22;Name&#x22;, function()
	{
		return this.name;
	});
	this.ordinal=function()
	{
		return this.ordinal_Renamed_Field;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.errorlevel.forBits" id="apidoc.element.jsqrcode.errorlevel.forBits">
        function <span class="apidocSignatureSpan">jsqrcode.errorlevel.</span>forBits
        <span class="apidocSignatureSpan">( bits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forBits = function ( bits)
{
	if (bits &#x3c; 0 || bits &#x3e;= FOR_BITS.Length)
	{
		throw &#x22;ArgumentException&#x22;;
	}
	return FOR_BITS[bits];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var FORMAT_INFO_MASK_QR = 0x5412;
var FORMAT_INFO_DECODE_LOOKUP = new Array(new Array(0x5412, 0x00), new Array(0x5125, 0x01), new Array(0x5E7C, 0x02), new Array(0x5B4B
, 0x03), new Array(0x45F9, 0x04), new Array(0x40CE, 0x05), new Array(0x4F97, 0x06), new Array(0x4AA0, 0x07), new Array(0x77C4, 0x08
), new Array(0x72F3, 0x09), new Array(0x7DAA, 0x0A), new Array(0x789D, 0x0B), new Array(0x662F, 0x0C), new Array(0x6318, 0x0D),
new Array(0x6C41, 0x0E), new Array(0x6976, 0x0F), new Array(0x1689, 0x10), new Array(0x13BE, 0x11), new Array(0x1CE7, 0x12), new
 Array(0x19D0, 0x13), new Array(0x0762, 0x14), new Array(0x0255, 0x15), new Array(0x0D0C, 0x16), new Array(0x083B, 0x17), new Array
(0x355F, 0x18), new Array(0x3068, 0x19), new Array(0x3F31, 0x1A), new Array(0x3A06, 0x1B), new Array(0x24B4, 0x1C), new Array(0x2183
, 0x1D), new Array(0x2EDA, 0x1E), new Array(0x2BED, 0x1F));
var BITS_SET_IN_HALF_BYTE = new Array(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);


function FormatInformation(formatInfo)
{
	this.errorCorrectionLevel = ErrorCorrectionLevel.<span class="apidocCodeKeywordSpan">forBits</span>((formatInfo &#x3e;&#x3e; 3) &#
x26; 0x03);
	this.dataMask =  (formatInfo &#x26; 0x07);

	this.__defineGetter__(&#x22;ErrorCorrectionLevel&#x22;, function()
	{
		return this.errorCorrectionLevel;
	});
	this.__defineGetter__(&#x22;DataMask&#x22;, function()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.findpat" id="apidoc.module.jsqrcode.findpat">module jsqrcode.findpat</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.findpat.findpat" id="apidoc.element.jsqrcode.findpat.findpat">
        function <span class="apidocSignatureSpan">jsqrcode.</span>findpat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FinderPatternFinder()
{
  this.image=null;
  this.possibleCenters = [];
  this.hasSkipped = false;
  this.crossCheckStateCount = new Array(0,0,0,0,0);
  this.resultPointCallback = null;

  this.__defineGetter__(&#x22;CrossCheckStateCount&#x22;, function()
  {
    this.crossCheckStateCount[0] = 0;
    this.crossCheckStateCount[1] = 0;
    this.crossCheckStateCount[2] = 0;
    this.crossCheckStateCount[3] = 0;
    this.crossCheckStateCount[4] = 0;
    return this.crossCheckStateCount;
  });

  this.foundPatternCross=function( stateCount)
    {
      var totalModuleSize = 0;
      for (var i = 0; i &#x3c; 5; i++)
      {
        var count = stateCount[i];
        if (count == 0)
        {
          return false;
        }
        totalModuleSize += count;
      }
      if (totalModuleSize &#x3c; 7)
      {
        return false;
      }
      var moduleSize = Math.floor((totalModuleSize &#x3c;&#x3c; INTEGER_MATH_SHIFT) / 7);
      var maxVariance = Math.floor(moduleSize / 2);
      // Allow less than 50% variance from 1-1-3-1-1 proportions
      return Math.abs(moduleSize - (stateCount[0] &#x3c;&#x3c; INTEGER_MATH_SHIFT)) &#x3c; maxVariance &#x26;&#x26; Math.abs(moduleSize - (stateCount[1] &#x3c;&#x3c;
INTEGER_MATH_SHIFT)) &#x3c; maxVariance &#x26;&#x26; Math.abs(3 * moduleSize - (stateCount[2] &#x3c;&#x3c; INTEGER_MATH_SHIFT)) &#x3c; 3 * maxVariance &#x26;&#x26; Math
.abs(moduleSize - (stateCount[3] &#x3c;&#x3c; INTEGER_MATH_SHIFT)) &#x3c; maxVariance &#x26;&#x26; Math.abs(moduleSize - (stateCount[4] &#x3c;&#x3c; INTEGER_MATH_SHIFT
)) &#x3c; maxVariance;
    }
  this.centerFromEnd=function( stateCount,  end)
    {
      return  (end - stateCount[4] - stateCount[3]) - stateCount[2] / 2.0;
    }
  this.crossCheckVertical=function( startI,  centerJ,  maxCount,  originalStateCountTotal)
    {
      var image = this.image;

      var maxI = qrcode.height;
      var stateCount = this.CrossCheckStateCount;

      // Start counting up from center
      var i = startI;
      while (i &#x3e;= 0 &#x26;&#x26; image[centerJ + i*qrcode.width])
      {
        stateCount[2]++;
        i--;
      }
      if (i &#x3c; 0)
      {
        return NaN;
      }
      while (i &#x3e;= 0 &#x26;&#x26; !image[centerJ +i*qrcode.width] &#x26;&#x26; stateCount[1] &#x3c;= maxCount)
      {
        stateCount[1]++;
        i--;
      }
      // If already too many modules in this state or ran off the edge:
      if (i &#x3c; 0 || stateCount[1] &#x3e; maxCount)
      {
        return NaN;
      }
      while (i &#x3e;= 0 &#x26;&#x26; image[centerJ + i*qrcode.width] &#x26;&#x26; stateCount[0] &#x3c;= maxCount)
      {
        stateCount[0]++;
        i--;
      }
      if (stateCount[0] &#x3e; maxCount)
      {
        return NaN;
      }

      // Now also count down from center
      i = startI + 1;
      while (i &#x3c; maxI &#x26;&#x26; image[centerJ +i*qrcode.width])
      {
        stateCount[2]++;
        i++;
      }
      if (i == maxI)
      {
        return NaN;
      }
      while (i &#x3c; maxI &#x26;&#x26; !image[centerJ + i*qrcode.width] &#x26;&#x26; stateCount[3] &#x3c; maxCount)
      {
        stateCount[3]++;
        i++;
      }
      if (i == maxI || stateCount[3] &#x3e;= maxCount)
      {
        return NaN;
      }
      while (i &#x3c; maxI &#x26;&#x26; image[centerJ + i*qrcode.width] &#x26;&#x26; stateCount[4] &#x3c; maxCount)
      {
        stateCount[4]++;
        i++;
      }
      if (stateCount[4] &#x3e;= maxCount)
      {
        return NaN;
      }

      // If we found a finder-pattern-like section, but its size is more than 40% different than
      // the original, assume it&#x27;s a false positive
      var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
      if (5 * Math.abs(stateCountTotal - originalStateCountTotal) &#x3e;= 2 * originalStateCountTotal)
      {
        return NaN;
      }

      return this.foundPatternCross(stateCount)?this.centerFromEnd(stateCount, i):NaN;
    }
  this.crossCheckHorizontal=function( startJ,  centerI,  maxCount, originalStateCountTotal)
    {
      var image = this.image;

      var maxJ = qrcode.width;
      var stateCount = this.CrossCheckStateCount;

      var j = startJ;
      wh ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.formatinf" id="apidoc.module.jsqrcode.formatinf">module jsqrcode.formatinf</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.formatinf.formatinf" id="apidoc.element.jsqrcode.formatinf.formatinf">
        function <span class="apidocSignatureSpan">jsqrcode.</span>formatinf
        <span class="apidocSignatureSpan">(formatInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FormatInformation(formatInfo)
{
	this.errorCorrectionLevel = ErrorCorrectionLevel.forBits((formatInfo &#x3e;&#x3e; 3) &#x26; 0x03);
	this.dataMask =  (formatInfo &#x26; 0x07);

	this.__defineGetter__(&#x22;ErrorCorrectionLevel&#x22;, function()
	{
		return this.errorCorrectionLevel;
	});
	this.__defineGetter__(&#x22;DataMask&#x22;, function()
	{
		return this.dataMask;
	});
	this.GetHashCode=function()
	{
		return (this.errorCorrectionLevel.ordinal() &#x3c;&#x3c; 3) |  dataMask;
	}
	this.Equals=function( o)
	{
		var other =  o;
		return this.errorCorrectionLevel == other.errorCorrectionLevel &#x26;&#x26; this.dataMask == other.dataMask;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.formatinf.decodeFormatInformation" id="apidoc.element.jsqrcode.formatinf.decodeFormatInformation">
        function <span class="apidocSignatureSpan">jsqrcode.formatinf.</span>decodeFormatInformation
        <span class="apidocSignatureSpan">( maskedFormatInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeFormatInformation = function ( maskedFormatInfo)
{
	var formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo);
	if (formatInfo != null)
	{
		return formatInfo;
	}
	// Should return null, but, some QR codes apparently
	// do not mask this info. Try again by actually masking the pattern
	// first
	return FormatInformation.doDecodeFormatInformation(maskedFormatInfo ^ FORMAT_INFO_MASK_QR);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
formatInfoBits = this.copyBit(8, 7, formatInfoBits);
// .. and skip a bit in the timing pattern ...
for (var j = 5; j &#x3e;= 0; j--)
{
  formatInfoBits = this.copyBit(8, j, formatInfoBits);
}

this.parsedFormatInfo = FormatInformation.<span class="apidocCodeKeywordSpan">decodeFormatInformation</span>(formatInfoBits);
if (this.parsedFormatInfo != null)
{
  return this.parsedFormatInfo;
}

// Hmm, failed. Try the top-right/bottom-left pattern
var dimension = this.bitMatrix.Dimension;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.formatinf.doDecodeFormatInformation" id="apidoc.element.jsqrcode.formatinf.doDecodeFormatInformation">
        function <span class="apidocSignatureSpan">jsqrcode.formatinf.</span>doDecodeFormatInformation
        <span class="apidocSignatureSpan">( maskedFormatInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doDecodeFormatInformation = function ( maskedFormatInfo)
{
	// Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing
	var bestDifference = 0xffffffff;
	var bestFormatInfo = 0;
	for (var i = 0; i &#x3c; FORMAT_INFO_DECODE_LOOKUP.length; i++)
	{
		var decodeInfo = FORMAT_INFO_DECODE_LOOKUP[i];
		var targetInfo = decodeInfo[0];
		if (targetInfo == maskedFormatInfo)
		{
			// Found an exact match
			return new FormatInformation(decodeInfo[1]);
		}
		var bitsDifference = this.numBitsDiffering(maskedFormatInfo, targetInfo);
		if (bitsDifference &#x3c; bestDifference)
		{
			bestFormatInfo = decodeInfo[1];
			bestDifference = bitsDifference;
		}
	}
	// Hamming distance of the 32 masked codes is 7, by construction, so &#x3c;= 3 bits
	// differing means we found a match
	if (bestDifference &#x3c;= 3)
	{
		return new FormatInformation(bestFormatInfo);
	}
	return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 20) &#x26; 0x0F)]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 24) &#x26; 0x0F)]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 28) &#x26; 0x0F)];
}

FormatInformation.decodeFormatInformation=function( maskedFormatInfo)
{
	var formatInfo = FormatInformation.<span class="apidocCodeKeywordSpan">doDecodeFormatInformation</span>(maskedFormatInfo);
	if (formatInfo != null)
	{
		return formatInfo;
	}
	// Should return null, but, some QR codes apparently
	// do not mask this info. Try again by actually masking the pattern
	// first
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.formatinf.numBitsDiffering" id="apidoc.element.jsqrcode.formatinf.numBitsDiffering">
        function <span class="apidocSignatureSpan">jsqrcode.formatinf.</span>numBitsDiffering
        <span class="apidocSignatureSpan">( a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numBitsDiffering = function ( a, b)
{
	a ^= b; // a now has a 1 bit exactly where its bit differs with b&#x27;s
	// Count bits set quickly with a series of lookups:
	return BITS_SET_IN_HALF_BYTE[a &#x26; 0x0F]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 4) &#x26; 0x0F)]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 8) &#x26; 0x0F)]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 12) &#x26; 0x0F)]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 16) &#x26; 0x0F)]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 20) &#x26; 0x0F)]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 24) &#x26; 0x0F)]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 28) &#x26; 0x0F)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		var decodeInfo = FORMAT_INFO_DECODE_LOOKUP[i];
		var targetInfo = decodeInfo[0];
		if (targetInfo == maskedFormatInfo)
		{
			// Found an exact match
			return new FormatInformation(decodeInfo[1]);
		}
		var bitsDifference = this.<span class="apidocCodeKeywordSpan">numBitsDiffering</span>(maskedFormatInfo, targetInfo);
		if (bitsDifference &#x3c; bestDifference)
		{
			bestFormatInfo = decodeInfo[1];
			bestDifference = bitsDifference;
		}
	}
	// Hamming distance of the 32 masked codes is 7, by construction, so &#x3c;= 3 bits
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.gf256" id="apidoc.module.jsqrcode.gf256">module jsqrcode.gf256</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.gf256.gf256" id="apidoc.element.jsqrcode.gf256.gf256">
        function <span class="apidocSignatureSpan">jsqrcode.</span>gf256
        <span class="apidocSignatureSpan">( primitive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gf256 = function ( primitive)
{
  this.expTable = new Array(256);
  this.logTable = new Array(256);
  // delayed dep injection
  if(!GF256Poly) GF256Poly = require(&#x27;./gf256poly&#x27;);
  var x = 1;
  for (var i = 0; i &#x3c; 256; i++)
  {
    this.expTable[i] = x;
    x &#x3c;&#x3c;= 1; // x = x * 2; we&#x27;re assuming the generator alpha is 2
    if (x &#x3e;= 0x100)
    {
      x ^= primitive;
    }
  }
  for (var i = 0; i &#x3c; 255; i++)
  {
    this.logTable[this.expTable[i]] = i;
  }
  // logTable[0] == 0 but this should never be used
  var at0=new Array(1);at0[0]=0;
  this.zero = new GF256Poly(this, new Array(at0));
  var at1=new Array(1);at1[0]=1;
  this.one = new GF256Poly(this, new Array(at1));

  this.__defineGetter__(&#x22;Zero&#x22;, function()
  {
    return this.zero;
  });
  this.__defineGetter__(&#x22;One&#x22;, function()
  {
    return this.one;
  });
  this.buildMonomial=function( degree,  coefficient)
    {
      if (degree &#x3c; 0)
      {
        throw &#x22;System.ArgumentException&#x22;;
      }
      if (coefficient == 0)
      {
        return zero;
      }
      var coefficients = new Array(degree + 1);
      for(var i=0;i&#x3c;coefficients.length;i++)coefficients[i]=0;
      coefficients[0] = coefficient;
      return new GF256Poly(this, coefficients);
    }
  this.exp=function(a)
    {
      return this.expTable[a];
    }
  this.log=function(a)
    {
      if (a == 0)
      {
        throw &#x22;System.ArgumentException&#x22;;
      }
      return this.logTable[a];
    }
  this.inverse=function(a)
    {
      if (a == 0)
      {
        throw &#x22;System.ArithmeticException&#x22;;
      }
      return this.expTable[255 - this.logTable[a]];
    }
  this.multiply=function(a, b) {
    if (a == 0 || b == 0) return 0;
    else if (a == 1) return b;
    else if (b == 1) return a;
    return this.expTable[(this.logTable[a] + this.logTable[b]) % 255];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.gf256.addOrSubtract" id="apidoc.element.jsqrcode.gf256.addOrSubtract">
        function <span class="apidocSignatureSpan">jsqrcode.gf256.</span>addOrSubtract
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addOrSubtract = function (a, b) {
  return a ^ b;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
var size = this.coefficients.length;
if (a == 1)
{
  // Just the sum of the coefficients
  var result = 0;
  for (var i = 0; i &#x3c; size; i++) {
    result = GF256.<span class="apidocCodeKeywordSpan">addOrSubtract</span>(result, this.coefficients[i]);
  }
  return result;
}
var result2 = this.coefficients[0];
for (var i = 1; i &#x3c; size; i++)
{
  result2 = GF256.addOrSubtract(this.field.multiply(a, result2), this.coefficients[i]);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.gf256poly" id="apidoc.module.jsqrcode.gf256poly">module jsqrcode.gf256poly</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.gf256poly.gf256poly" id="apidoc.element.jsqrcode.gf256poly.gf256poly">
        function <span class="apidocSignatureSpan">jsqrcode.</span>gf256poly
        <span class="apidocSignatureSpan">(field, coefficients)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function GF256Poly(field, coefficients)
{
  if (coefficients == null || coefficients.length == 0)
    throw new Error(&#x22;GF256Poly bad arguments. no coefficients provided&#x22;);
  if(!GF256) GF256 = require(&#x27;./gf256&#x27;);
  this.field = field;
  var coefficientsLength = coefficients.length;
  if (coefficientsLength &#x3e; 1 &#x26;&#x26; coefficients[0] == 0)
  {
    // Leading term must be non-zero for anything except the constant polynomial &#x22;0&#x22;
    var firstNonZero = 1;
    while (firstNonZero &#x3c; coefficientsLength &#x26;&#x26; coefficients[firstNonZero] == 0)
    {
      firstNonZero++;
    }
    if (firstNonZero == coefficientsLength)
    {
      this.coefficients = field.Zero.coefficients;
    }
    else
    {
      this.coefficients = new Array(coefficientsLength - firstNonZero);
      for(var i=0;i&#x3c;this.coefficients.length;i++)this.coefficients[i]=0;
      //Array.Copy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
      for(var ci=0;ci&#x3c;this.coefficients.length;ci++)this.coefficients[ci]=coefficients[firstNonZero+ci];
    }
  }
  else
  {
    this.coefficients = coefficients;
  }

  this.__defineGetter__(&#x22;Zero&#x22;, function()
  {
    return this.coefficients[0] == 0;
  });
  this.__defineGetter__(&#x22;Degree&#x22;, function()
  {
    return this.coefficients.length - 1;
  });
  this.__defineGetter__(&#x22;Coefficients&#x22;, function()
  {
    return this.coefficients;
  });

  this.getCoefficient=function( degree)
  {
    return this.coefficients[this.coefficients.length - 1 - degree];
  }

  this.evaluateAt=function( a)
  {
    if (a == 0)
    {
      // Just return the x^0 coefficient
      return this.getCoefficient(0);
    }
    var size = this.coefficients.length;
    if (a == 1)
    {
      // Just the sum of the coefficients
      var result = 0;
      for (var i = 0; i &#x3c; size; i++) {
        result = GF256.addOrSubtract(result, this.coefficients[i]);
      }
      return result;
    }
    var result2 = this.coefficients[0];
    for (var i = 1; i &#x3c; size; i++)
    {
      result2 = GF256.addOrSubtract(this.field.multiply(a, result2), this.coefficients[i]);
    }
    return result2;
  }

  this.addOrSubtract = function( other)
    {
      if (this.field != other.field)
      {
        throw &#x22;GF256Polys do not have same GF256 field&#x22;;
      }
      if (this.Zero)
      {
        return other;
      }
      if (other.Zero)
      {
        return this;
      }

      var smallerCoefficients = this.coefficients;
      var largerCoefficients = other.coefficients;
      if (smallerCoefficients.length &#x3e; largerCoefficients.length)
      {
        var temp = smallerCoefficients;
        smallerCoefficients = largerCoefficients;
        largerCoefficients = temp;
      }
      var sumDiff = new Array(largerCoefficients.length);
      var lengthDiff = largerCoefficients.length - smallerCoefficients.length;
      // Copy high-order terms only found in higher-degree polynomial&#x27;s coefficients
      //Array.Copy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
      for(var ci=0;ci&#x3c;lengthDiff;ci++)sumDiff[ci]=largerCoefficients[ci];

      for (var i = lengthDiff; i &#x3c; largerCoefficients.length; i++)
      {
        sumDiff[i] = GF256.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
      }

      return new GF256Poly(field, sumDiff);
  }
  this.multiply1=function( other)
    {
      if (this.field!=other.field)
      {
        throw &#x22;GF256Polys do not have same GF256 field&#x22;;
      }
      if (this.Zero || other.Zero)
      {
        return this.field.Zero;
      }
      var aCoefficients = this.coefficients;
      var aLength = aCoefficients.length;
      var bCoefficients = other.coefficients;
      var bLength = bCoefficients.length;
      var product = new Array(aLength + bLength - 1);
      for (var i = 0; i &#x3c; aLength; i++)
      {
        var aCoeff = aCoefficients[i];
        for (var j = 0; j &#x3c; bLength; j++)
        {
          product[i + j] = GF256.addOrSubtract ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.grid" id="apidoc.module.jsqrcode.grid">module jsqrcode.grid</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.grid.checkAndNudgePoints" id="apidoc.element.jsqrcode.grid.checkAndNudgePoints">
        function <span class="apidocSignatureSpan">jsqrcode.grid.</span>checkAndNudgePoints
        <span class="apidocSignatureSpan">( image, points)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAndNudgePoints = function ( image, points) {
  var width = qrcode.width;
  var height = qrcode.height;
  // Check and nudge points from start until we see some that are OK:
  var nudged = true;
  for (var offset = 0; offset &#x3c; points.Length &#x26;&#x26; nudged; offset += 2) {
var x = Math.floor (points[offset]);
var y = Math.floor( points[offset + 1]);
if (x &#x3c; - 1 || x &#x3e; width || y &#x3c; - 1 || y &#x3e; height)
    {
      throw &#x22;Error.checkAndNudgePoints &#x22;;
    }
    nudged = false;
    if (x == - 1)
    {
      points[offset] = 0.0;
      nudged = true;
    }
    else if (x == width)
    {
      points[offset] = width - 1;
      nudged = true;
    }
    if (y == - 1)
    {
      points[offset + 1] = 0.0;
      nudged = true;
    }
    else if (y == height)
    {
      points[offset + 1] = height - 1;
      nudged = true;
    }
  }
  // Check and nudge points from end:
  nudged = true;
  for (var offset = points.Length - 2; offset &#x3e;= 0 &#x26;&#x26; nudged; offset -= 2)
  {
    var x = Math.floor( points[offset]);
    var y = Math.floor( points[offset + 1]);
    if (x &#x3c; - 1 || x &#x3e; width || y &#x3c; - 1 || y &#x3e; height)
    {
      throw &#x22;Error.checkAndNudgePoints &#x22;;
    }
    nudged = false;
    if (x == - 1)
    {
      points[offset] = 0.0;
      nudged = true;
    }
    else if (x == width)
    {
      points[offset] = width - 1;
      nudged = true;
    }
    if (y == - 1)
    {
      points[offset + 1] = 0.0;
      nudged = true;
    }
    else if (y == height)
    {
      points[offset + 1] = height - 1;
      nudged = true;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
{
  points[x] =  (x &#x3e;&#x3e; 1) + 0.5;
  points[x + 1] = iValue;
}
transform.transformPoints1(points);
// Quick check to see if points transformed to something inside the image;
// sufficient to check the endpoints
GridSampler.<span class="apidocCodeKeywordSpan">checkAndNudgePoints</span>(image, points);
try
{
  for (var x = 0; x &#x3c; max; x += 2)
  {
    var xpoint = (Math.floor( points[x]) * 4) + (Math.floor( points[x + 1]) * qrcode.width * 4);
                var bit = image[Math.floor( points[x])+ qrcode.width* Math.floor( points[x + 1])];
    qrcode.imagedata.data[xpoint] = bit?255:0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.grid.sampleGrid3" id="apidoc.element.jsqrcode.grid.sampleGrid3">
        function <span class="apidocSignatureSpan">jsqrcode.grid.</span>sampleGrid3
        <span class="apidocSignatureSpan">( image, dimension, transform)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sampleGrid3 = function ( image, dimension, transform)
{
  var bits = new BitMatrix(dimension);
  var points = new Array(dimension &#x3c;&#x3c; 1);
  for (var y = 0; y &#x3c; dimension; y++)
  {
    var max = points.length;
    var iValue =  y + 0.5;
    for (var x = 0; x &#x3c; max; x += 2)
    {
      points[x] =  (x &#x3e;&#x3e; 1) + 0.5;
      points[x + 1] = iValue;
    }
    transform.transformPoints1(points);
    // Quick check to see if points transformed to something inside the image;
    // sufficient to check the endpoints
    GridSampler.checkAndNudgePoints(image, points);
    try
    {
      for (var x = 0; x &#x3c; max; x += 2)
      {
        var xpoint = (Math.floor( points[x]) * 4) + (Math.floor( points[x + 1]) * qrcode.width * 4);
                    var bit = image[Math.floor( points[x])+ qrcode.width* Math.floor( points[x + 1])];
        qrcode.imagedata.data[xpoint] = bit?255:0;
        qrcode.imagedata.data[xpoint+1] = bit?255:0;
        qrcode.imagedata.data[xpoint+2] = 0;
        qrcode.imagedata.data[xpoint+3] = 255;
        //bits[x &#x3e;&#x3e; 1][ y]=bit;
        if(bit)
          bits.set_Renamed(x &#x3e;&#x3e; 1, y);
      }
    }
    catch ( aioobe)
    {
      // This feels wrong, but, sometimes if the finder patterns are misidentified, the resulting
      // transform gets &#x22;twisted&#x22; such that it maps a straight line of points to a set of points
      // whose endpoints are in bounds, but others are not. There is probably some mathematical
      // way to detect this about the transformation that I don&#x27;t know yet.
      // This results in an ugly runtime exception despite our clever checks above -- can&#x27;t have
      // that. We could check each point&#x27;s coordinates but that feels duplicative. We settle for
      // catching and wrapping ArrayIndexOutOfBoundsException.
      throw &#x22;Error.checkAndNudgePoints&#x22;;
    }
  }
  return bits;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return transform;
  }

this.sampleGrid = function( image,  transform,  dimension)
  {

    var sampler = grid;
    return sampler.<span class="apidocCodeKeywordSpan">sampleGrid3</span>(image, dimension, transform);
  }

this.processFinderPatternInfo = function( info)
  {

    var topLeft = info.TopLeft;
    var topRight = info.TopRight;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.grid.sampleGridx" id="apidoc.element.jsqrcode.grid.sampleGridx">
        function <span class="apidocSignatureSpan">jsqrcode.grid.</span>sampleGridx
        <span class="apidocSignatureSpan">( image, dimension, p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY , p3FromX, p3FromY, p4FromX, p4FromY)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sampleGridx = function ( image, dimension, p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY , p3FromX, p3FromY, p4FromX, p4FromY)
{
  var transform = PerspectiveTransform.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX
, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);

  return GridSampler.sampleGrid3(image, dimension, transform);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.perspective_transform" id="apidoc.module.jsqrcode.perspective_transform">module jsqrcode.perspective_transform</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.perspective_transform.perspective_transform" id="apidoc.element.jsqrcode.perspective_transform.perspective_transform">
        function <span class="apidocSignatureSpan">jsqrcode.</span>perspective_transform
        <span class="apidocSignatureSpan">( a11, a21, a31, a12, a22, a32, a13, a23, a33)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PerspectiveTransform( a11, a21, a31, a12, a22, a32, a13, a23, a33)
{
	this.a11 = a11;
	this.a12 = a12;
	this.a13 = a13;
	this.a21 = a21;
	this.a22 = a22;
	this.a23 = a23;
	this.a31 = a31;
	this.a32 = a32;
	this.a33 = a33;
	this.transformPoints1=function( points)
		{
			var max = points.length;
			var a11 = this.a11;
			var a12 = this.a12;
			var a13 = this.a13;
			var a21 = this.a21;
			var a22 = this.a22;
			var a23 = this.a23;
			var a31 = this.a31;
			var a32 = this.a32;
			var a33 = this.a33;
			for (var i = 0; i &#x3c; max; i += 2)
			{
				var x = points[i];
				var y = points[i + 1];
				var denominator = a13 * x + a23 * y + a33;
				points[i] = (a11 * x + a21 * y + a31) / denominator;
				points[i + 1] = (a12 * x + a22 * y + a32) / denominator;
			}
		}
	this. transformPoints2=function(xValues, yValues)
		{
			var n = xValues.length;
			for (var i = 0; i &#x3c; n; i++)
			{
				var x = xValues[i];
				var y = yValues[i];
				var denominator = this.a13 * x + this.a23 * y + this.a33;
				xValues[i] = (this.a11 * x + this.a21 * y + this.a31) / denominator;
				yValues[i] = (this.a12 * x + this.a22 * y + this.a32) / denominator;
			}
		}

	this.buildAdjoint=function()
		{
			// Adjoint is the transpose of the cofactor matrix:
			return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21
 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12
 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11
 * this.a22 - this.a12 * this.a21);
		}
	this.times=function( other)
		{
			return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this
.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11
 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other
.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 +this.a33 * other.a13, this.a13 *
other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
		}

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.perspective_transform.quadrilateralToQuadrilateral" id="apidoc.element.jsqrcode.perspective_transform.quadrilateralToQuadrilateral">
        function <span class="apidocSignatureSpan">jsqrcode.perspective_transform.</span>quadrilateralToQuadrilateral
        <span class="apidocSignatureSpan">( x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">quadrilateralToQuadrilateral = function ( x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p)
{
	
	var qToS = this.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
	var sToQ = this.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
	return sToQ.times(qToS);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    {
      // Don&#x27;t have an alignment pattern, just make up the bottom-right point
      bottomRightX = (topRight.X - topLeft.X) + bottomLeft.X;
      bottomRightY = (topRight.Y - topLeft.Y) + bottomLeft.Y;
      sourceBottomRightX = sourceBottomRightY = dimMinusThree;
    }

    var transform = PerspectiveTransform.<span class="apidocCodeKeywordSpan">quadrilateralToQuadrilateral</span>(3.5, 3.5, dimMinusThree
, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.X, topLeft.Y, topRight.X, topRight.Y, bottomRightX, bottomRightY
, bottomLeft.X, bottomLeft.Y);

    return transform;
  }

this.sampleGrid = function( image,  transform,  dimension)
  {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.perspective_transform.quadrilateralToSquare" id="apidoc.element.jsqrcode.perspective_transform.quadrilateralToSquare">
        function <span class="apidocSignatureSpan">jsqrcode.perspective_transform.</span>quadrilateralToSquare
        <span class="apidocSignatureSpan">( x0, y0, x1, y1, x2, y2, x3, y3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">quadrilateralToSquare = function ( x0, y0, x1, y1, x2, y2, x3, y3)
{
	// Here, the adjoint serves as the inverse:
	return this.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}

}

PerspectiveTransform.quadrilateralToQuadrilateral=function( x0,  y0,  x1,  y1,  x2,  y2,  x3,  y3,  x0p,  y0p,  x1p,  y1p,  x2p,
y2p,  x3p,  y3p)
{
	
	var qToS = this.<span class="apidocCodeKeywordSpan">quadrilateralToSquare</span>(x0, y0, x1, y1, x2, y2, x3, y3);
	var sToQ = this.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
	return sToQ.times(qToS);
}

PerspectiveTransform.squareToQuadrilateral=function( x0,  y0,  x1,  y1,  x2,  y2,  x3,  y3)
{
	 dy2 = y3 - y2;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.perspective_transform.squareToQuadrilateral" id="apidoc.element.jsqrcode.perspective_transform.squareToQuadrilateral">
        function <span class="apidocSignatureSpan">jsqrcode.perspective_transform.</span>squareToQuadrilateral
        <span class="apidocSignatureSpan">( x0, y0, x1, y1, x2, y2, x3, y3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">squareToQuadrilateral = function ( x0, y0, x1, y1, x2, y2, x3, y3)
{
	 dy2 = y3 - y2;
	 dy3 = y0 - y1 + y2 - y3;
	if (dy2 == 0.0 &#x26;&#x26; dy3 == 0.0)
	{
		return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0.0, 0.0, 1.0);
	}
	else
	{
		 dx1 = x1 - x2;
		 dx2 = x3 - x2;
		 dx3 = x0 - x1 + x2 - x3;
		 dy1 = y1 - y2;
		 denominator = dx1 * dy2 - dx2 * dy1;
		 a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
		 a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
		return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23
, 1.0);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

}

PerspectiveTransform.quadrilateralToQuadrilateral=function( x0,  y0,  x1,  y1,  x2,  y2,  x3,  y3,  x0p,  y0p,  x1p,  y1p,  x2p,
y2p,  x3p,  y3p)
{
	
	var qToS = this.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
	var sToQ = this.<span class="apidocCodeKeywordSpan">squareToQuadrilateral</span>(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
	return sToQ.times(qToS);
}

PerspectiveTransform.squareToQuadrilateral=function( x0,  y0,  x1,  y1,  x2,  y2,  x3,  y3)
{
	 dy2 = y3 - y2;
	 dy3 = y0 - y1 + y2 - y3;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.rsdecoder" id="apidoc.module.jsqrcode.rsdecoder">module jsqrcode.rsdecoder</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.rsdecoder.rsdecoder" id="apidoc.element.jsqrcode.rsdecoder.rsdecoder">
        function <span class="apidocSignatureSpan">jsqrcode.</span>rsdecoder
        <span class="apidocSignatureSpan">(field)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReedSolomonDecoder(field)
{
  this.field = field;
  this.decode=function(received,  twoS)
  {
      var poly = new GF256Poly(this.field, received);
      var syndromeCoefficients = new Array(twoS);
      for(var i=0;i&#x3c;syndromeCoefficients.length;i++)syndromeCoefficients[i]=0;
      var dataMatrix = false;//this.field.Equals(GF256.DATA_MATRIX_FIELD);
      var noError = true;
      for (var i = 0; i &#x3c; twoS; i++)
      {
        // Thanks to sanfordsquires for this fix:
        var eval = poly.evaluateAt(this.field.exp(dataMatrix?i + 1:i));
        syndromeCoefficients[syndromeCoefficients.length - 1 - i] = eval;
        if (eval != 0)
        {
          noError = false;
        }
      }
      if (noError)
      {
        return ;
      }
      var syndrome = new GF256Poly(this.field, syndromeCoefficients);
      var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(twoS, 1), syndrome, twoS);
      var sigma = sigmaOmega[0];
      var omega = sigmaOmega[1];
      var errorLocations = this.findErrorLocations(sigma);
      var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations, dataMatrix);
      for (var i = 0; i &#x3c; errorLocations.length; i++)
      {
        var position = received.length - 1 - this.field.log(errorLocations[i]);
        if (position &#x3c; 0)
        {
          throw &#x22;ReedSolomonException Bad error location&#x22;;
        }
        received[position] = GF256.addOrSubtract(received[position], errorMagnitudes[i]);
      }
  }

  this.runEuclideanAlgorithm=function( a,  b,  R)
    {
      // Assume a&#x27;s degree is &#x3e;= b&#x27;s
      if (a.Degree &#x3c; b.Degree)
      {
        var temp = a;
        a = b;
        b = temp;
      }

      var rLast = a;
      var r = b;
      var sLast = this.field.One;
      var s = this.field.Zero;
      var tLast = this.field.Zero;
      var t = this.field.One;

      // Run Euclidean algorithm until r&#x27;s degree is less than R/2
      while (r.Degree &#x3e;= Math.floor(R / 2))
      {
        var rLastLast = rLast;
        var sLastLast = sLast;
        var tLastLast = tLast;
        rLast = r;
        sLast = s;
        tLast = t;

        // Divide rLastLast by rLast, with quotient in q and remainder in r
        if (rLast.Zero)
        {
          // Oops, Euclidean algorithm already terminated?
          throw &#x22;r_{i-1} was zero&#x22;;
        }
        r = rLastLast;
        var q = this.field.Zero;
        var denominatorLeadingTerm = rLast.getCoefficient(rLast.Degree);
        var dltInverse = this.field.inverse(denominatorLeadingTerm);
        while (r.Degree &#x3e;= rLast.Degree &#x26;&#x26; !r.Zero)
        {
          var degreeDiff = r.Degree - rLast.Degree;
          var scale = this.field.multiply(r.getCoefficient(r.Degree), dltInverse);
          q = q.addOrSubtract(this.field.buildMonomial(degreeDiff, scale));
          r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
          //r.EXE();
        }

        s = q.multiply1(sLast).addOrSubtract(sLastLast);
        t = q.multiply1(tLast).addOrSubtract(tLastLast);
      }

      var sigmaTildeAtZero = t.getCoefficient(0);
      if (sigmaTildeAtZero == 0)
      {
        throw &#x22;ReedSolomonException sigmaTilde(0) was zero&#x22;;
      }

      var inverse = this.field.inverse(sigmaTildeAtZero);
      var sigma = t.multiply2(inverse);
      var omega = r.multiply2(inverse);
      return new Array(sigma, omega);
    }
  this.findErrorLocations=function( errorLocator)
    {
      // This is a direct application of Chien&#x27;s search
      var numErrors = errorLocator.Degree;
      if (numErrors == 1)
      {
        // shortcut
        return new Array(errorLocator.getCoefficient(1));
      }
      var result = new Array(numErrors);
      var e = 0;
      for (var i = 1; i &#x3c; 256 &#x26;&#x26; e &#x3c; numErrors; i++)
      {
        if (errorLocator.evaluateAt(i) == 0)
        {
          result[e] = this.field.inverse(i);
          e++;
        }
      }
      if (e != nu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.toString" id="apidoc.module.jsqrcode.toString">module jsqrcode.toString</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.toString.toString" id="apidoc.element.jsqrcode.toString.toString">
        function <span class="apidocSignatureSpan">jsqrcode.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.version" id="apidoc.module.jsqrcode.version">module jsqrcode.version</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.version.version" id="apidoc.element.jsqrcode.version.version">
        function <span class="apidocSignatureSpan">jsqrcode.</span>version
        <span class="apidocSignatureSpan">( versionNumber, alignmentPatternCenters, ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Version( versionNumber, alignmentPatternCenters, ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4)
{
  this.versionNumber = versionNumber;
  this.alignmentPatternCenters = alignmentPatternCenters;
  this.ecBlocks = new Array(ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4);

  var total = 0;
  var ecCodewords = ecBlocks1.ECCodewordsPerBlock;
  var ecbArray = ecBlocks1.getECBlocks();
  for (var i = 0; i &#x3c; ecbArray.length; i++)
  {
    var ecBlock = ecbArray[i];
    total += ecBlock.Count * (ecBlock.DataCodewords + ecCodewords);
  }
  this.totalCodewords = total;

  this.__defineGetter__(&#x22;VersionNumber&#x22;, function()
  {
    return  this.versionNumber;
  });

  this.__defineGetter__(&#x22;AlignmentPatternCenters&#x22;, function()
  {
    return  this.alignmentPatternCenters;
  });
  this.__defineGetter__(&#x22;TotalCodewords&#x22;, function()
  {
    return  this.totalCodewords;
  });
  this.__defineGetter__(&#x22;DimensionForVersion&#x22;, function()
  {
    return  17 + 4 * this.versionNumber;
  });

  this.buildFunctionPattern=function()
    {
      var dimension = this.DimensionForVersion;
      var bitMatrix = new BitMatrix(dimension);

      // Top left finder pattern + separator + format
      bitMatrix.setRegion(0, 0, 9, 9);
      // Top right finder pattern + separator + format
      bitMatrix.setRegion(dimension - 8, 0, 8, 9);
      // Bottom left finder pattern + separator + format
      bitMatrix.setRegion(0, dimension - 8, 9, 8);

      // Alignment patterns
      var max = this.alignmentPatternCenters.length;
      for (var x = 0; x &#x3c; max; x++)
      {
        var i = this.alignmentPatternCenters[x] - 2;
        for (var y = 0; y &#x3c; max; y++)
        {
          if ((x == 0 &#x26;&#x26; (y == 0 || y == max - 1)) || (x == max - 1 &#x26;&#x26; y == 0))
          {
            // No alignment patterns near the three finder paterns
            continue;
          }
          bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);
        }
      }

      // Vertical timing pattern
      bitMatrix.setRegion(6, 9, 1, dimension - 17);
      // Horizontal timing pattern
      bitMatrix.setRegion(9, 6, dimension - 17, 1);

      if (this.versionNumber &#x3e; 6)
      {
        // Version info, top right
        bitMatrix.setRegion(dimension - 11, 0, 3, 6);
        // Version info, bottom left
        bitMatrix.setRegion(0, dimension - 11, 6, 3);
      }

      return bitMatrix;
    }
  this.getECBlocksForLevel=function( ecLevel)
  {
    return this.ecBlocks[ecLevel.ordinal()];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.version.decodeVersionInformation" id="apidoc.element.jsqrcode.version.decodeVersionInformation">
        function <span class="apidocSignatureSpan">jsqrcode.version.</span>decodeVersionInformation
        <span class="apidocSignatureSpan">( versionBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeVersionInformation = function ( versionBits)
{
  var bestDifference = 0xffffffff;
  var bestVersion = 0;
  for (var i = 0; i &#x3c; Version.VERSION_DECODE_INFO.length; i++)
  {
    var targetVersion = Version.VERSION_DECODE_INFO[i];
    // Do the version info bits match exactly? done.
    if (targetVersion == versionBits)
    {
      return this.getVersionForNumber(i + 7);
    }
    // Otherwise see if this is the closest to a real version info bit string
    // we have seen so far
    var bitsDifference = FormatInformation.numBitsDiffering(versionBits, targetVersion);
    if (bitsDifference &#x3c; bestDifference)
    {
      bestVersion = i + 7;
      bestDifference = bitsDifference;
    }
  }
  // We can tolerate up to 3 bits of error since no two version info codewords will
  // differ in less than 4 bits.
  if (bestDifference &#x3c;= 3)
  {
    return this.getVersionForNumber(bestVersion);
  }
  // If we didn&#x27;t find a close enough match, fail
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
{
  for (var i = dimension - 9; i &#x3e;= ijMin; i--)
  {
    versionBits = this.copyBit(i, j, versionBits);
  }
}

this.parsedVersion = Version.<span class="apidocCodeKeywordSpan">decodeVersionInformation</span>(versionBits);
if (this.parsedVersion != null &#x26;&#x26; this.parsedVersion.DimensionForVersion == dimension)
{
  return this.parsedVersion;
}

// Hmm, failed. Try bottom left: 6 wide by 3 tall
versionBits = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.version.getProvisionalVersionForDimension" id="apidoc.element.jsqrcode.version.getProvisionalVersionForDimension">
        function <span class="apidocSignatureSpan">jsqrcode.version.</span>getProvisionalVersionForDimension
        <span class="apidocSignatureSpan">(dimension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getProvisionalVersionForDimension = function (dimension)
{
  if (dimension % 4 != 1)
  {
    throw &#x22;Error getProvisionalVersionForDimension&#x22;;
  }
  try
  {
    return Version.getVersionForNumber((dimension - 17) &#x3e;&#x3e; 2);
  }
  catch ( iae)
  {
    throw &#x22;Error getVersionForNumber&#x22;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);
if (moduleSize &#x3c; 1.0)
{
  throw &#x22;Error&#x22;;
}
var dimension = this.computeDimension(topLeft, topRight, bottomLeft, moduleSize);
var provisionalVersion = Version.<span class="apidocCodeKeywordSpan">getProvisionalVersionForDimension</span>(dimension);
var modulesBetweenFPCenters = provisionalVersion.DimensionForVersion - 7;

var alignmentPattern = null;
// Anything above version 1 has an alignment pattern
if (provisionalVersion.AlignmentPatternCenters.length &#x3e; 0)
{
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.version.getVersionForNumber" id="apidoc.element.jsqrcode.version.getVersionForNumber">
        function <span class="apidocSignatureSpan">jsqrcode.version.</span>getVersionForNumber
        <span class="apidocSignatureSpan">( versionNumber)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getVersionForNumber = function ( versionNumber)
{
  if (versionNumber &#x3c; 1 || versionNumber &#x3e; 40)
  {
    throw &#x22;ArgumentException&#x22;;
  }
  return Version.VERSIONS[versionNumber - 1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var dimension = this.bitMatrix.Dimension;

var provisionalVersion = (dimension - 17) &#x3e;&#x3e; 2;
if (provisionalVersion &#x3c;= 6)
{
  return Version.<span class="apidocCodeKeywordSpan">getVersionForNumber</span>(provisionalVersion);
}

// Read top-right version info: 3 wide by 6 tall
var versionBits = 0;
var ijMin = dimension - 11;
for (var j = 5; j &#x3e;= 0; j--)
{
...</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
