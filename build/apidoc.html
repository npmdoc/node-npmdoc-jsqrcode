<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/vicapow/jsqrcode#readme"

    >jsqrcode (v0.0.7)</a>
</h1>
<h4>a node port of Lazar Laszlo's `jsqrcode` qr code decoder</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode">module jsqrcode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.jsqrcode">
            function <span class="apidocSignatureSpan"></span>jsqrcode
            <span class="apidocSignatureSpan">(Canvas)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.datablock">
            function <span class="apidocSignatureSpan">jsqrcode.</span>datablock
            <span class="apidocSignatureSpan">(numDataCodewords, codewords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.errorlevel">
            function <span class="apidocSignatureSpan">jsqrcode.</span>errorlevel
            <span class="apidocSignatureSpan">(ordinal, bits, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.formatinf">
            function <span class="apidocSignatureSpan">jsqrcode.</span>formatinf
            <span class="apidocSignatureSpan">(formatInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.gf256">
            function <span class="apidocSignatureSpan">jsqrcode.</span>gf256
            <span class="apidocSignatureSpan">( primitive)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.perspective_transform">
            function <span class="apidocSignatureSpan">jsqrcode.</span>perspective_transform
            <span class="apidocSignatureSpan">( a11, a21, a31, a12, a22, a32, a13, a23, a33)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.version">
            function <span class="apidocSignatureSpan">jsqrcode.</span>version
            <span class="apidocSignatureSpan">( versionNumber, alignmentPatternCenters, ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.</span>datamask</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.</span>decoder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.</span>grid</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.datablock">module jsqrcode.datablock</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.datablock.datablock">
            function <span class="apidocSignatureSpan">jsqrcode.</span>datablock
            <span class="apidocSignatureSpan">(numDataCodewords, codewords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.datablock.getDataBlocks">
            function <span class="apidocSignatureSpan">jsqrcode.datablock.</span>getDataBlocks
            <span class="apidocSignatureSpan">(rawCodewords, version, ecLevel)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.datamask">module jsqrcode.datamask</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.datamask.forReference">
            function <span class="apidocSignatureSpan">jsqrcode.datamask.</span>forReference
            <span class="apidocSignatureSpan">(reference)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.datamask.</span>DATA_MASKS</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.decoder">module jsqrcode.decoder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.decoder.correctErrors">
            function <span class="apidocSignatureSpan">jsqrcode.decoder.</span>correctErrors
            <span class="apidocSignatureSpan">( codewordBytes, numDataCodewords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.decoder.decode">
            function <span class="apidocSignatureSpan">jsqrcode.decoder.</span>decode
            <span class="apidocSignatureSpan">(bits)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.decoder.</span>rsDecoder</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.errorlevel">module jsqrcode.errorlevel</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.errorlevel.errorlevel">
            function <span class="apidocSignatureSpan">jsqrcode.</span>errorlevel
            <span class="apidocSignatureSpan">(ordinal, bits, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.errorlevel.forBits">
            function <span class="apidocSignatureSpan">jsqrcode.errorlevel.</span>forBits
            <span class="apidocSignatureSpan">( bits)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.formatinf">module jsqrcode.formatinf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.formatinf.formatinf">
            function <span class="apidocSignatureSpan">jsqrcode.</span>formatinf
            <span class="apidocSignatureSpan">(formatInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.formatinf.decodeFormatInformation">
            function <span class="apidocSignatureSpan">jsqrcode.formatinf.</span>decodeFormatInformation
            <span class="apidocSignatureSpan">( maskedFormatInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.formatinf.doDecodeFormatInformation">
            function <span class="apidocSignatureSpan">jsqrcode.formatinf.</span>doDecodeFormatInformation
            <span class="apidocSignatureSpan">( maskedFormatInfo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.formatinf.numBitsDiffering">
            function <span class="apidocSignatureSpan">jsqrcode.formatinf.</span>numBitsDiffering
            <span class="apidocSignatureSpan">( a, b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.gf256">module jsqrcode.gf256</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.gf256.gf256">
            function <span class="apidocSignatureSpan">jsqrcode.</span>gf256
            <span class="apidocSignatureSpan">( primitive)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.gf256.addOrSubtract">
            function <span class="apidocSignatureSpan">jsqrcode.gf256.</span>addOrSubtract
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.gf256.</span>DATA_MATRIX_FIELD</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.gf256.</span>QR_CODE_FIELD</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.grid">module jsqrcode.grid</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.grid.checkAndNudgePoints">
            function <span class="apidocSignatureSpan">jsqrcode.grid.</span>checkAndNudgePoints
            <span class="apidocSignatureSpan">( image, points)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.grid.sampleGrid3">
            function <span class="apidocSignatureSpan">jsqrcode.grid.</span>sampleGrid3
            <span class="apidocSignatureSpan">( image, dimension, transform)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.grid.sampleGridx">
            function <span class="apidocSignatureSpan">jsqrcode.grid.</span>sampleGridx
            <span class="apidocSignatureSpan">( image, dimension, p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY , p3FromX, p3FromY, p4FromX, p4FromY)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.perspective_transform">module jsqrcode.perspective_transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.perspective_transform.perspective_transform">
            function <span class="apidocSignatureSpan">jsqrcode.</span>perspective_transform
            <span class="apidocSignatureSpan">( a11, a21, a31, a12, a22, a32, a13, a23, a33)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.perspective_transform.quadrilateralToQuadrilateral">
            function <span class="apidocSignatureSpan">jsqrcode.perspective_transform.</span>quadrilateralToQuadrilateral
            <span class="apidocSignatureSpan">( x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.perspective_transform.quadrilateralToSquare">
            function <span class="apidocSignatureSpan">jsqrcode.perspective_transform.</span>quadrilateralToSquare
            <span class="apidocSignatureSpan">( x0, y0, x1, y1, x2, y2, x3, y3)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.perspective_transform.squareToQuadrilateral">
            function <span class="apidocSignatureSpan">jsqrcode.perspective_transform.</span>squareToQuadrilateral
            <span class="apidocSignatureSpan">( x0, y0, x1, y1, x2, y2, x3, y3)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsqrcode.version">module jsqrcode.version</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.version.version">
            function <span class="apidocSignatureSpan">jsqrcode.</span>version
            <span class="apidocSignatureSpan">( versionNumber, alignmentPatternCenters, ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.version.decodeVersionInformation">
            function <span class="apidocSignatureSpan">jsqrcode.version.</span>decodeVersionInformation
            <span class="apidocSignatureSpan">( versionBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.version.getProvisionalVersionForDimension">
            function <span class="apidocSignatureSpan">jsqrcode.version.</span>getProvisionalVersionForDimension
            <span class="apidocSignatureSpan">(dimension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsqrcode.version.getVersionForNumber">
            function <span class="apidocSignatureSpan">jsqrcode.version.</span>getVersionForNumber
            <span class="apidocSignatureSpan">( versionNumber)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.version.</span>VERSIONS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsqrcode.version.</span>VERSION_DECODE_INFO</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode" id="apidoc.module.jsqrcode">module jsqrcode</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.jsqrcode" id="apidoc.element.jsqrcode.jsqrcode">
        function <span class="apidocSignatureSpan"></span>jsqrcode
        <span class="apidocSignatureSpan">(Canvas)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsqrcode = function (Canvas){
  // if the qrcode instance exists, return it
  if(qrcode) return qrcode;
  // if not, create it, then return it
  qrcode = {};
  var Image = null, isCanvas = null, createCanvas = null;

  if(typeof window!=&#x27;undefined&#x27;) {
    // XXX Fix for node-webkit not finding HTMLCanvasElement and document
    // outside window.
    HTMLCanvasElement = window.HTMLCanvasElement;
    document = window.document;

    // we&#x27;re in the browser
    if(typeof HTMLCanvasElement !== &#x27;undefined&#x27; ){
      createCanvas = function(width,height){
        var canvas = document.createElement(&#x22;canvas&#x22;);
        canvas.setAttribute(&#x27;width&#x27;, width);
        canvas.setAttribute(&#x27;height&#x27;, height);
        return canvas;
      }
    }else throw new Error(&#x22;the HTML5 Canvas element is not supported in &#x22;
      + &#x22;this browser&#x22;);
    Image = window.Image;
    if(!Image) throw new Error(&#x22;the Image element is not supported in &#x22;
      + &#x22;this browser&#x22;);
    isCanvas = function(instance){
      return instance instanceof HTMLCanvasElement;
    }
  }else{
    // // on the server!
    createCanvas = function(width,height){
      return new Canvas(width,height);
    }
    isCanvas = function(instance){
      return instance instanceof Canvas;
    }
    var s = require; //trick browserify into not including canvas
    if(!Canvas) Canvas = s(&#x27;canvas&#x27;);
    Image = Canvas.Image;
  }

  var Decoder = require(&#x27;./decoder&#x27;);
  var grid = require(&#x27;./grid&#x27;);
  var Detector = require(&#x27;./detector&#x27;);

  // TODO: remove this. should avoid extending built in types
  Array.prototype.remove = function(from, to) {
    var rest = this.slice((to || from) + 1 || this.length);
    this.length = from &#x3c; 0 ? this.length + from : from;
    return this.push.apply(this, rest);
  };


  qrcode.imagedata = null;
  qrcode.width = 0;
  qrcode.height = 0;
  qrcode.qrCodeSymbol = null;
  qrcode.debug = false;

  qrcode.sizeOfDataLengthInfo =  [  [ 10, 9, 8, 8 ],  [ 12, 11, 16, 10 ],  [ 14, 13, 16, 12 ] ];

  qrcode.decode = function(src){
    var canvas_qr = null
        , context = null;
    if( isCanvas(src) ){
      canvas_qr = src;
      context = canvas_qr.getContext(&#x27;2d&#x27;);
      qrcode.width = canvas_qr.width;
      qrcode.height = canvas_qr.height;
      qrcode.imagedata = context.getImageData(0, 0, qrcode.width, qrcode.height);
      return qrcode.process(context);
    }else if( src instanceof Image){
      return imageLoaded(src);
    }else{
      throw new Error(&#x27;jsqrcode can only decode a canvas or image element&#x27;);
    }
    function imageLoaded(image){
      canvas_qr = createCanvas(image.width, image.height);
      context = canvas_qr.getContext(&#x27;2d&#x27;);
      var canvas_out = createCanvas(image.width, image.height);
      if(canvas_out!==null){
        var outctx = canvas_out.getContext(&#x27;2d&#x27;);
        outctx.clearRect(0, 0, 320, 240);
        outctx.drawImage(image, 0, 0, 320, 240);
      }
      qrcode.width = canvas_qr.width;
      qrcode.height = canvas_qr.height;
      context.drawImage(image, 0, 0,canvas_qr.width,canvas_qr.height);
      try{
        qrcode.imagedata = context.getImageData(0, 0, canvas_qr.width, canvas_qr.height);
      }catch(e){
        throw new Error(&#x22;Cross domain image reading not supported in your &#x22;
          + &#x22;browser! Save it to your computer then drag and drop the file!&#x22;);
      }
      return qrcode.process(context);
    }
  }

  qrcode.decode_utf8 = function ( s ) {
    return decodeURIComponent( escape( s ) );
  }

  qrcode.process = function(ctx){
    var start = new Date().getTime();
    var image = qrcode.grayScaleToBitmap(qrcode.grayscale());
    //var image = qrcode.binarize(128);
    if(qrcode.debug){
      for (var y = 0; y &#x3c; qrcode.height; y++) {
        for (var x = 0; x &#x3c; qrcode.width; x++) {
          var point = (x * 4) + (y * qrcode.width * 4);
          qrcode.imagedata.data[point] = image[x+y*qrcode.width]?0:0;
          qrcode.imagedata.data[point+1] = image[x+y*qrcode.width]?0:0;
          qrcode.image ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.datablock" id="apidoc.element.jsqrcode.datablock">
        function <span class="apidocSignatureSpan">jsqrcode.</span>datablock
        <span class="apidocSignatureSpan">(numDataCodewords, codewords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataBlock(numDataCodewords, codewords)
{
	this.numDataCodewords = numDataCodewords;
	this.codewords = codewords;
	
	this.__defineGetter__(&#x22;NumDataCodewords&#x22;, function()
	{
		return this.numDataCodewords;
	});
	this.__defineGetter__(&#x22;Codewords&#x22;, function()
	{
		return this.codewords;
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.errorlevel" id="apidoc.element.jsqrcode.errorlevel">
        function <span class="apidocSignatureSpan">jsqrcode.</span>errorlevel
        <span class="apidocSignatureSpan">(ordinal, bits, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ErrorCorrectionLevel(ordinal, bits, name)
{
	this.ordinal_Renamed_Field = ordinal;
	this.bits = bits;
	this.name = name;
	this.__defineGetter__(&#x22;Bits&#x22;, function()
	{
		return this.bits;
	});
	this.__defineGetter__(&#x22;Name&#x22;, function()
	{
		return this.name;
	});
	this.ordinal=function()
	{
		return this.ordinal_Renamed_Field;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.formatinf" id="apidoc.element.jsqrcode.formatinf">
        function <span class="apidocSignatureSpan">jsqrcode.</span>formatinf
        <span class="apidocSignatureSpan">(formatInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FormatInformation(formatInfo)
{
	this.errorCorrectionLevel = ErrorCorrectionLevel.forBits((formatInfo &#x3e;&#x3e; 3) &#x26; 0x03);
	this.dataMask =  (formatInfo &#x26; 0x07);

	this.__defineGetter__(&#x22;ErrorCorrectionLevel&#x22;, function()
	{
		return this.errorCorrectionLevel;
	});
	this.__defineGetter__(&#x22;DataMask&#x22;, function()
	{
		return this.dataMask;
	});
	this.GetHashCode=function()
	{
		return (this.errorCorrectionLevel.ordinal() &#x3c;&#x3c; 3) |  dataMask;
	}
	this.Equals=function( o)
	{
		var other =  o;
		return this.errorCorrectionLevel == other.errorCorrectionLevel &#x26;&#x26; this.dataMask == other.dataMask;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.gf256" id="apidoc.element.jsqrcode.gf256">
        function <span class="apidocSignatureSpan">jsqrcode.</span>gf256
        <span class="apidocSignatureSpan">( primitive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gf256 = function ( primitive)
{
  this.expTable = new Array(256);
  this.logTable = new Array(256);
  // delayed dep injection
  if(!GF256Poly) GF256Poly = require(&#x27;./gf256poly&#x27;);
  var x = 1;
  for (var i = 0; i &#x3c; 256; i++)
  {
    this.expTable[i] = x;
    x &#x3c;&#x3c;= 1; // x = x * 2; we&#x27;re assuming the generator alpha is 2
    if (x &#x3e;= 0x100)
    {
      x ^= primitive;
    }
  }
  for (var i = 0; i &#x3c; 255; i++)
  {
    this.logTable[this.expTable[i]] = i;
  }
  // logTable[0] == 0 but this should never be used
  var at0=new Array(1);at0[0]=0;
  this.zero = new GF256Poly(this, new Array(at0));
  var at1=new Array(1);at1[0]=1;
  this.one = new GF256Poly(this, new Array(at1));

  this.__defineGetter__(&#x22;Zero&#x22;, function()
  {
    return this.zero;
  });
  this.__defineGetter__(&#x22;One&#x22;, function()
  {
    return this.one;
  });
  this.buildMonomial=function( degree,  coefficient)
    {
      if (degree &#x3c; 0)
      {
        throw &#x22;System.ArgumentException&#x22;;
      }
      if (coefficient == 0)
      {
        return zero;
      }
      var coefficients = new Array(degree + 1);
      for(var i=0;i&#x3c;coefficients.length;i++)coefficients[i]=0;
      coefficients[0] = coefficient;
      return new GF256Poly(this, coefficients);
    }
  this.exp=function(a)
    {
      return this.expTable[a];
    }
  this.log=function(a)
    {
      if (a == 0)
      {
        throw &#x22;System.ArgumentException&#x22;;
      }
      return this.logTable[a];
    }
  this.inverse=function(a)
    {
      if (a == 0)
      {
        throw &#x22;System.ArithmeticException&#x22;;
      }
      return this.expTable[255 - this.logTable[a]];
    }
  this.multiply=function(a, b) {
    if (a == 0 || b == 0) return 0;
    else if (a == 1) return b;
    else if (b == 1) return a;
    return this.expTable[(this.logTable[a] + this.logTable[b]) % 255];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.perspective_transform" id="apidoc.element.jsqrcode.perspective_transform">
        function <span class="apidocSignatureSpan">jsqrcode.</span>perspective_transform
        <span class="apidocSignatureSpan">( a11, a21, a31, a12, a22, a32, a13, a23, a33)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PerspectiveTransform( a11, a21, a31, a12, a22, a32, a13, a23, a33)
{
	this.a11 = a11;
	this.a12 = a12;
	this.a13 = a13;
	this.a21 = a21;
	this.a22 = a22;
	this.a23 = a23;
	this.a31 = a31;
	this.a32 = a32;
	this.a33 = a33;
	this.transformPoints1=function( points)
		{
			var max = points.length;
			var a11 = this.a11;
			var a12 = this.a12;
			var a13 = this.a13;
			var a21 = this.a21;
			var a22 = this.a22;
			var a23 = this.a23;
			var a31 = this.a31;
			var a32 = this.a32;
			var a33 = this.a33;
			for (var i = 0; i &#x3c; max; i += 2)
			{
				var x = points[i];
				var y = points[i + 1];
				var denominator = a13 * x + a23 * y + a33;
				points[i] = (a11 * x + a21 * y + a31) / denominator;
				points[i + 1] = (a12 * x + a22 * y + a32) / denominator;
			}
		}
	this. transformPoints2=function(xValues, yValues)
		{
			var n = xValues.length;
			for (var i = 0; i &#x3c; n; i++)
			{
				var x = xValues[i];
				var y = yValues[i];
				var denominator = this.a13 * x + this.a23 * y + this.a33;
				xValues[i] = (this.a11 * x + this.a21 * y + this.a31) / denominator;
				yValues[i] = (this.a12 * x + this.a22 * y + this.a32) / denominator;
			}
		}

	this.buildAdjoint=function()
		{
			// Adjoint is the transpose of the cofactor matrix:
			return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21
 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12
 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11
 * this.a22 - this.a12 * this.a21);
		}
	this.times=function( other)
		{
			return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this
.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11
 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other
.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 +this.a33 * other.a13, this.a13 *
other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
		}

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.version" id="apidoc.element.jsqrcode.version">
        function <span class="apidocSignatureSpan">jsqrcode.</span>version
        <span class="apidocSignatureSpan">( versionNumber, alignmentPatternCenters, ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Version( versionNumber, alignmentPatternCenters, ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4)
{
  this.versionNumber = versionNumber;
  this.alignmentPatternCenters = alignmentPatternCenters;
  this.ecBlocks = new Array(ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4);

  var total = 0;
  var ecCodewords = ecBlocks1.ECCodewordsPerBlock;
  var ecbArray = ecBlocks1.getECBlocks();
  for (var i = 0; i &#x3c; ecbArray.length; i++)
  {
    var ecBlock = ecbArray[i];
    total += ecBlock.Count * (ecBlock.DataCodewords + ecCodewords);
  }
  this.totalCodewords = total;

  this.__defineGetter__(&#x22;VersionNumber&#x22;, function()
  {
    return  this.versionNumber;
  });

  this.__defineGetter__(&#x22;AlignmentPatternCenters&#x22;, function()
  {
    return  this.alignmentPatternCenters;
  });
  this.__defineGetter__(&#x22;TotalCodewords&#x22;, function()
  {
    return  this.totalCodewords;
  });
  this.__defineGetter__(&#x22;DimensionForVersion&#x22;, function()
  {
    return  17 + 4 * this.versionNumber;
  });

  this.buildFunctionPattern=function()
    {
      var dimension = this.DimensionForVersion;
      var bitMatrix = new BitMatrix(dimension);

      // Top left finder pattern + separator + format
      bitMatrix.setRegion(0, 0, 9, 9);
      // Top right finder pattern + separator + format
      bitMatrix.setRegion(dimension - 8, 0, 8, 9);
      // Bottom left finder pattern + separator + format
      bitMatrix.setRegion(0, dimension - 8, 9, 8);

      // Alignment patterns
      var max = this.alignmentPatternCenters.length;
      for (var x = 0; x &#x3c; max; x++)
      {
        var i = this.alignmentPatternCenters[x] - 2;
        for (var y = 0; y &#x3c; max; y++)
        {
          if ((x == 0 &#x26;&#x26; (y == 0 || y == max - 1)) || (x == max - 1 &#x26;&#x26; y == 0))
          {
            // No alignment patterns near the three finder paterns
            continue;
          }
          bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);
        }
      }

      // Vertical timing pattern
      bitMatrix.setRegion(6, 9, 1, dimension - 17);
      // Horizontal timing pattern
      bitMatrix.setRegion(9, 6, dimension - 17, 1);

      if (this.versionNumber &#x3e; 6)
      {
        // Version info, top right
        bitMatrix.setRegion(dimension - 11, 0, 3, 6);
        // Version info, bottom left
        bitMatrix.setRegion(0, dimension - 11, 6, 3);
      }

      return bitMatrix;
    }
  this.getECBlocksForLevel=function( ecLevel)
  {
    return this.ecBlocks[ecLevel.ordinal()];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.datablock" id="apidoc.module.jsqrcode.datablock">module jsqrcode.datablock</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.datablock.datablock" id="apidoc.element.jsqrcode.datablock.datablock">
        function <span class="apidocSignatureSpan">jsqrcode.</span>datablock
        <span class="apidocSignatureSpan">(numDataCodewords, codewords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DataBlock(numDataCodewords, codewords)
{
	this.numDataCodewords = numDataCodewords;
	this.codewords = codewords;
	
	this.__defineGetter__(&#x22;NumDataCodewords&#x22;, function()
	{
		return this.numDataCodewords;
	});
	this.__defineGetter__(&#x22;Codewords&#x22;, function()
	{
		return this.codewords;
	});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.datablock.getDataBlocks" id="apidoc.element.jsqrcode.datablock.getDataBlocks">
        function <span class="apidocSignatureSpan">jsqrcode.datablock.</span>getDataBlocks
        <span class="apidocSignatureSpan">(rawCodewords, version, ecLevel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDataBlocks = function (rawCodewords, version, ecLevel)
{
	
	if (rawCodewords.length != version.TotalCodewords)
	{
		throw &#x22;ArgumentException&#x22;;
	}
	
	// Figure out the number and size of data blocks used by this version and
	// error correction level
	var ecBlocks = version.getECBlocksForLevel(ecLevel);
	
	// First count the total number of data blocks
	var totalBlocks = 0;
	var ecBlockArray = ecBlocks.getECBlocks();
	for (var i = 0; i &#x3c; ecBlockArray.length; i++)
	{
		totalBlocks += ecBlockArray[i].Count;
	}
	
	// Now establish DataBlocks of the appropriate size and number of data codewords
	var result = new Array(totalBlocks);
	var numResultBlocks = 0;
	for (var j = 0; j &#x3c; ecBlockArray.length; j++)
	{
		var ecBlock = ecBlockArray[j];
		for (var i = 0; i &#x3c; ecBlock.Count; i++)
		{
			var numDataCodewords = ecBlock.DataCodewords;
			var numBlockCodewords = ecBlocks.ECCodewordsPerBlock + numDataCodewords;
			result[numResultBlocks++] = new DataBlock(numDataCodewords, new Array(numBlockCodewords));
		}
	}
	
	// All blocks have the same amount of data, except that the last n
	// (where n may be 0) have 1 more byte. Figure out where these start.
	var shorterBlocksTotalCodewords = result[0].codewords.length;
	var longerBlocksStartAt = result.length - 1;
	while (longerBlocksStartAt &#x3e;= 0)
	{
		var numCodewords = result[longerBlocksStartAt].codewords.length;
		if (numCodewords == shorterBlocksTotalCodewords)
		{
			break;
		}
		longerBlocksStartAt--;
	}
	longerBlocksStartAt++;
	
	var shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.ECCodewordsPerBlock;
	// The last elements of result may be 1 element longer;
	// first fill out as many elements as all of them have
	var rawCodewordsOffset = 0;
	for (var i = 0; i &#x3c; shorterBlocksNumDataCodewords; i++)
	{
		for (var j = 0; j &#x3c; numResultBlocks; j++)
		{
			result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
		}
	}
	// Fill out the last data block in the longer ones
	for (var j = longerBlocksStartAt; j &#x3c; numResultBlocks; j++)
	{
		result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];
	}
	// Now add in error correction blocks
	var max = result[0].codewords.length;
	for (var i = shorterBlocksNumDataCodewords; i &#x3c; max; i++)
	{
		for (var j = 0; j &#x3c; numResultBlocks; j++)
		{
			var iOffset = j &#x3c; longerBlocksStartAt?i:i + 1;
			result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
		}
	}
	return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var version = parser.readVersion();
var ecLevel = parser.readFormatInformation().ErrorCorrectionLevel;

// Read codewords
var codewords = parser.readCodewords();

// Separate into data blocks
var dataBlocks = DataBlock.<span class="apidocCodeKeywordSpan">getDataBlocks</span>(codewords, version, ecLevel);

// Count total number of data bytes
var totalBytes = 0;
for (var i = 0; i &#x3c; dataBlocks.Length; i++)
{
  totalBytes += dataBlocks[i].NumDataCodewords;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.datamask" id="apidoc.module.jsqrcode.datamask">module jsqrcode.datamask</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.datamask.forReference" id="apidoc.element.jsqrcode.datamask.forReference">
        function <span class="apidocSignatureSpan">jsqrcode.datamask.</span>forReference
        <span class="apidocSignatureSpan">(reference)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forReference = function (reference)
{
  if (reference &#x3c; 0 || reference &#x3e; 7)
  {
    throw &#x22;System.ArgumentException&#x22;;
  }
  return DataMask.DATA_MASKS[reference];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    {

var formatInfo = this.readFormatInformation();
var version = this.readVersion();

// Get the data mask for the format used in this QR Code. This will exclude
// some bits from reading as we wind through the bit matrix.
var dataMask = DataMask.<span class="apidocCodeKeywordSpan">forReference</span>( formatInfo.DataMask);
var dimension = this.bitMatrix.Dimension;
dataMask.unmaskBitMatrix(this.bitMatrix, dimension);

var functionPattern = version.buildFunctionPattern();

var readingUp = true;
var result = new Array(version.TotalCodewords);
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.decoder" id="apidoc.module.jsqrcode.decoder">module jsqrcode.decoder</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.decoder.correctErrors" id="apidoc.element.jsqrcode.decoder.correctErrors">
        function <span class="apidocSignatureSpan">jsqrcode.decoder.</span>correctErrors
        <span class="apidocSignatureSpan">( codewordBytes, numDataCodewords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">correctErrors = function ( codewordBytes, numDataCodewords)
{
  var numCodewords = codewordBytes.length;
  // First read into an array of ints
  var codewordsInts = new Array(numCodewords);
  for (var i = 0; i &#x3c; numCodewords; i++)
  {
    codewordsInts[i] = codewordBytes[i] &#x26; 0xFF;
  }
  var numECCodewords = codewordBytes.length - numDataCodewords;
  try
  {
    Decoder.rsDecoder.decode(codewordsInts, numECCodewords);
    //var corrector = new ReedSolomon(codewordsInts, numECCodewords);
    //corrector.correct();
  }
  catch ( rse)
  {
    throw rse;
  }
  // Copy back into array of bytes -- only need to worry about the bytes that were data
  // We don&#x27;t care about errors in the error-correction codewords
  for (var i = 0; i &#x3c; numDataCodewords; i++)
  {
    codewordBytes[i] =  codewordsInts[i];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Error-correct and copy data blocks together into a stream of bytes
for (var j = 0; j &#x3c; dataBlocks.length; j++)
{
  var dataBlock = dataBlocks[j];
  var codewordBytes = dataBlock.Codewords;
  var numDataCodewords = dataBlock.NumDataCodewords;
  Decoder.<span class="apidocCodeKeywordSpan">correctErrors</span>(codewordBytes, numDataCodewords);
  for (var i = 0; i &#x3c; numDataCodewords; i++)
  {
    resultBytes[resultOffset++] = codewordBytes[i];
  }
}

// Decode the contents of that stream of bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.decoder.decode" id="apidoc.element.jsqrcode.decoder.decode">
        function <span class="apidocSignatureSpan">jsqrcode.decoder.</span>decode
        <span class="apidocSignatureSpan">(bits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (bits)
{
  var parser = new BitMatrixParser(bits);
  var version = parser.readVersion();
  var ecLevel = parser.readFormatInformation().ErrorCorrectionLevel;

  // Read codewords
  var codewords = parser.readCodewords();

  // Separate into data blocks
  var dataBlocks = DataBlock.getDataBlocks(codewords, version, ecLevel);

  // Count total number of data bytes
  var totalBytes = 0;
  for (var i = 0; i &#x3c; dataBlocks.Length; i++)
  {
    totalBytes += dataBlocks[i].NumDataCodewords;
  }
  var resultBytes = new Array(totalBytes);
  var resultOffset = 0;

  // Error-correct and copy data blocks together into a stream of bytes
  for (var j = 0; j &#x3c; dataBlocks.length; j++)
  {
    var dataBlock = dataBlocks[j];
    var codewordBytes = dataBlock.Codewords;
    var numDataCodewords = dataBlock.NumDataCodewords;
    Decoder.correctErrors(codewordBytes, numDataCodewords);
    for (var i = 0; i &#x3c; numDataCodewords; i++)
    {
      resultBytes[resultOffset++] = codewordBytes[i];
    }
  }

  // Decode the contents of that stream of bytes
  var reader = new QRCodeDataBlockReader(resultBytes, version.VersionNumber, ecLevel.Bits);
  return reader;
  //return DecodedBitStreamParser.decode(resultBytes, version, ecLevel);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for (var i = 0; i &#x3c; numCodewords; i++)
{
  codewordsInts[i] = codewordBytes[i] &#x26; 0xFF;
}
var numECCodewords = codewordBytes.length - numDataCodewords;
try
{
  Decoder.rsDecoder.<span class="apidocCodeKeywordSpan">decode</span>(codewordsInts, numECCodewords);
  //var corrector = new ReedSolomon(codewordsInts, numECCodewords);
  //corrector.correct();
}
catch ( rse)
{
  throw rse;
}
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.errorlevel" id="apidoc.module.jsqrcode.errorlevel">module jsqrcode.errorlevel</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.errorlevel.errorlevel" id="apidoc.element.jsqrcode.errorlevel.errorlevel">
        function <span class="apidocSignatureSpan">jsqrcode.</span>errorlevel
        <span class="apidocSignatureSpan">(ordinal, bits, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ErrorCorrectionLevel(ordinal, bits, name)
{
	this.ordinal_Renamed_Field = ordinal;
	this.bits = bits;
	this.name = name;
	this.__defineGetter__(&#x22;Bits&#x22;, function()
	{
		return this.bits;
	});
	this.__defineGetter__(&#x22;Name&#x22;, function()
	{
		return this.name;
	});
	this.ordinal=function()
	{
		return this.ordinal_Renamed_Field;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.errorlevel.forBits" id="apidoc.element.jsqrcode.errorlevel.forBits">
        function <span class="apidocSignatureSpan">jsqrcode.errorlevel.</span>forBits
        <span class="apidocSignatureSpan">( bits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forBits = function ( bits)
{
	if (bits &#x3c; 0 || bits &#x3e;= FOR_BITS.Length)
	{
		throw &#x22;ArgumentException&#x22;;
	}
	return FOR_BITS[bits];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var FORMAT_INFO_MASK_QR = 0x5412;
var FORMAT_INFO_DECODE_LOOKUP = new Array(new Array(0x5412, 0x00), new Array(0x5125, 0x01), new Array(0x5E7C, 0x02), new Array(0x5B4B
, 0x03), new Array(0x45F9, 0x04), new Array(0x40CE, 0x05), new Array(0x4F97, 0x06), new Array(0x4AA0, 0x07), new Array(0x77C4, 0x08
), new Array(0x72F3, 0x09), new Array(0x7DAA, 0x0A), new Array(0x789D, 0x0B), new Array(0x662F, 0x0C), new Array(0x6318, 0x0D),
new Array(0x6C41, 0x0E), new Array(0x6976, 0x0F), new Array(0x1689, 0x10), new Array(0x13BE, 0x11), new Array(0x1CE7, 0x12), new
 Array(0x19D0, 0x13), new Array(0x0762, 0x14), new Array(0x0255, 0x15), new Array(0x0D0C, 0x16), new Array(0x083B, 0x17), new Array
(0x355F, 0x18), new Array(0x3068, 0x19), new Array(0x3F31, 0x1A), new Array(0x3A06, 0x1B), new Array(0x24B4, 0x1C), new Array(0x2183
, 0x1D), new Array(0x2EDA, 0x1E), new Array(0x2BED, 0x1F));
var BITS_SET_IN_HALF_BYTE = new Array(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);


function FormatInformation(formatInfo)
{
	this.errorCorrectionLevel = ErrorCorrectionLevel.<span class="apidocCodeKeywordSpan">forBits</span>((formatInfo &#x3e;&#x3e; 3) &#
x26; 0x03);
	this.dataMask =  (formatInfo &#x26; 0x07);

	this.__defineGetter__(&#x22;ErrorCorrectionLevel&#x22;, function()
	{
		return this.errorCorrectionLevel;
	});
	this.__defineGetter__(&#x22;DataMask&#x22;, function()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.formatinf" id="apidoc.module.jsqrcode.formatinf">module jsqrcode.formatinf</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.formatinf.formatinf" id="apidoc.element.jsqrcode.formatinf.formatinf">
        function <span class="apidocSignatureSpan">jsqrcode.</span>formatinf
        <span class="apidocSignatureSpan">(formatInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function FormatInformation(formatInfo)
{
	this.errorCorrectionLevel = ErrorCorrectionLevel.forBits((formatInfo &#x3e;&#x3e; 3) &#x26; 0x03);
	this.dataMask =  (formatInfo &#x26; 0x07);

	this.__defineGetter__(&#x22;ErrorCorrectionLevel&#x22;, function()
	{
		return this.errorCorrectionLevel;
	});
	this.__defineGetter__(&#x22;DataMask&#x22;, function()
	{
		return this.dataMask;
	});
	this.GetHashCode=function()
	{
		return (this.errorCorrectionLevel.ordinal() &#x3c;&#x3c; 3) |  dataMask;
	}
	this.Equals=function( o)
	{
		var other =  o;
		return this.errorCorrectionLevel == other.errorCorrectionLevel &#x26;&#x26; this.dataMask == other.dataMask;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.formatinf.decodeFormatInformation" id="apidoc.element.jsqrcode.formatinf.decodeFormatInformation">
        function <span class="apidocSignatureSpan">jsqrcode.formatinf.</span>decodeFormatInformation
        <span class="apidocSignatureSpan">( maskedFormatInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeFormatInformation = function ( maskedFormatInfo)
{
	var formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo);
	if (formatInfo != null)
	{
		return formatInfo;
	}
	// Should return null, but, some QR codes apparently
	// do not mask this info. Try again by actually masking the pattern
	// first
	return FormatInformation.doDecodeFormatInformation(maskedFormatInfo ^ FORMAT_INFO_MASK_QR);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
formatInfoBits = this.copyBit(8, 7, formatInfoBits);
// .. and skip a bit in the timing pattern ...
for (var j = 5; j &#x3e;= 0; j--)
{
  formatInfoBits = this.copyBit(8, j, formatInfoBits);
}

this.parsedFormatInfo = FormatInformation.<span class="apidocCodeKeywordSpan">decodeFormatInformation</span>(formatInfoBits);
if (this.parsedFormatInfo != null)
{
  return this.parsedFormatInfo;
}

// Hmm, failed. Try the top-right/bottom-left pattern
var dimension = this.bitMatrix.Dimension;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.formatinf.doDecodeFormatInformation" id="apidoc.element.jsqrcode.formatinf.doDecodeFormatInformation">
        function <span class="apidocSignatureSpan">jsqrcode.formatinf.</span>doDecodeFormatInformation
        <span class="apidocSignatureSpan">( maskedFormatInfo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doDecodeFormatInformation = function ( maskedFormatInfo)
{
	// Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing
	var bestDifference = 0xffffffff;
	var bestFormatInfo = 0;
	for (var i = 0; i &#x3c; FORMAT_INFO_DECODE_LOOKUP.length; i++)
	{
		var decodeInfo = FORMAT_INFO_DECODE_LOOKUP[i];
		var targetInfo = decodeInfo[0];
		if (targetInfo == maskedFormatInfo)
		{
			// Found an exact match
			return new FormatInformation(decodeInfo[1]);
		}
		var bitsDifference = this.numBitsDiffering(maskedFormatInfo, targetInfo);
		if (bitsDifference &#x3c; bestDifference)
		{
			bestFormatInfo = decodeInfo[1];
			bestDifference = bitsDifference;
		}
	}
	// Hamming distance of the 32 masked codes is 7, by construction, so &#x3c;= 3 bits
	// differing means we found a match
	if (bestDifference &#x3c;= 3)
	{
		return new FormatInformation(bestFormatInfo);
	}
	return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 20) &#x26; 0x0F)]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 24) &#x26; 0x0F)]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 28) &#x26; 0x0F)];
}

FormatInformation.decodeFormatInformation=function( maskedFormatInfo)
{
	var formatInfo = FormatInformation.<span class="apidocCodeKeywordSpan">doDecodeFormatInformation</span>(maskedFormatInfo);
	if (formatInfo != null)
	{
		return formatInfo;
	}
	// Should return null, but, some QR codes apparently
	// do not mask this info. Try again by actually masking the pattern
	// first
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.formatinf.numBitsDiffering" id="apidoc.element.jsqrcode.formatinf.numBitsDiffering">
        function <span class="apidocSignatureSpan">jsqrcode.formatinf.</span>numBitsDiffering
        <span class="apidocSignatureSpan">( a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numBitsDiffering = function ( a, b)
{
	a ^= b; // a now has a 1 bit exactly where its bit differs with b&#x27;s
	// Count bits set quickly with a series of lookups:
	return BITS_SET_IN_HALF_BYTE[a &#x26; 0x0F]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 4) &#x26; 0x0F)]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 8) &#x26; 0x0F)]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 12) &#x26; 0x0F)]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 16) &#x26; 0x0F)]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 20) &#x26; 0x0F)]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 24) &#x26; 0x0F)]
	  + BITS_SET_IN_HALF_BYTE[(qrcode.URShift(a, 28) &#x26; 0x0F)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		var decodeInfo = FORMAT_INFO_DECODE_LOOKUP[i];
		var targetInfo = decodeInfo[0];
		if (targetInfo == maskedFormatInfo)
		{
			// Found an exact match
			return new FormatInformation(decodeInfo[1]);
		}
		var bitsDifference = this.<span class="apidocCodeKeywordSpan">numBitsDiffering</span>(maskedFormatInfo, targetInfo);
		if (bitsDifference &#x3c; bestDifference)
		{
			bestFormatInfo = decodeInfo[1];
			bestDifference = bitsDifference;
		}
	}
	// Hamming distance of the 32 masked codes is 7, by construction, so &#x3c;= 3 bits
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.gf256" id="apidoc.module.jsqrcode.gf256">module jsqrcode.gf256</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.gf256.gf256" id="apidoc.element.jsqrcode.gf256.gf256">
        function <span class="apidocSignatureSpan">jsqrcode.</span>gf256
        <span class="apidocSignatureSpan">( primitive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gf256 = function ( primitive)
{
  this.expTable = new Array(256);
  this.logTable = new Array(256);
  // delayed dep injection
  if(!GF256Poly) GF256Poly = require(&#x27;./gf256poly&#x27;);
  var x = 1;
  for (var i = 0; i &#x3c; 256; i++)
  {
    this.expTable[i] = x;
    x &#x3c;&#x3c;= 1; // x = x * 2; we&#x27;re assuming the generator alpha is 2
    if (x &#x3e;= 0x100)
    {
      x ^= primitive;
    }
  }
  for (var i = 0; i &#x3c; 255; i++)
  {
    this.logTable[this.expTable[i]] = i;
  }
  // logTable[0] == 0 but this should never be used
  var at0=new Array(1);at0[0]=0;
  this.zero = new GF256Poly(this, new Array(at0));
  var at1=new Array(1);at1[0]=1;
  this.one = new GF256Poly(this, new Array(at1));

  this.__defineGetter__(&#x22;Zero&#x22;, function()
  {
    return this.zero;
  });
  this.__defineGetter__(&#x22;One&#x22;, function()
  {
    return this.one;
  });
  this.buildMonomial=function( degree,  coefficient)
    {
      if (degree &#x3c; 0)
      {
        throw &#x22;System.ArgumentException&#x22;;
      }
      if (coefficient == 0)
      {
        return zero;
      }
      var coefficients = new Array(degree + 1);
      for(var i=0;i&#x3c;coefficients.length;i++)coefficients[i]=0;
      coefficients[0] = coefficient;
      return new GF256Poly(this, coefficients);
    }
  this.exp=function(a)
    {
      return this.expTable[a];
    }
  this.log=function(a)
    {
      if (a == 0)
      {
        throw &#x22;System.ArgumentException&#x22;;
      }
      return this.logTable[a];
    }
  this.inverse=function(a)
    {
      if (a == 0)
      {
        throw &#x22;System.ArithmeticException&#x22;;
      }
      return this.expTable[255 - this.logTable[a]];
    }
  this.multiply=function(a, b) {
    if (a == 0 || b == 0) return 0;
    else if (a == 1) return b;
    else if (b == 1) return a;
    return this.expTable[(this.logTable[a] + this.logTable[b]) % 255];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.gf256.addOrSubtract" id="apidoc.element.jsqrcode.gf256.addOrSubtract">
        function <span class="apidocSignatureSpan">jsqrcode.gf256.</span>addOrSubtract
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addOrSubtract = function (a, b) {
  return a ^ b;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
var size = this.coefficients.length;
if (a == 1)
{
  // Just the sum of the coefficients
  var result = 0;
  for (var i = 0; i &#x3c; size; i++) {
    result = GF256.<span class="apidocCodeKeywordSpan">addOrSubtract</span>(result, this.coefficients[i]);
  }
  return result;
}
var result2 = this.coefficients[0];
for (var i = 1; i &#x3c; size; i++)
{
  result2 = GF256.addOrSubtract(this.field.multiply(a, result2), this.coefficients[i]);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.grid" id="apidoc.module.jsqrcode.grid">module jsqrcode.grid</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.grid.checkAndNudgePoints" id="apidoc.element.jsqrcode.grid.checkAndNudgePoints">
        function <span class="apidocSignatureSpan">jsqrcode.grid.</span>checkAndNudgePoints
        <span class="apidocSignatureSpan">( image, points)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkAndNudgePoints = function ( image, points) {
  var width = qrcode.width;
  var height = qrcode.height;
  // Check and nudge points from start until we see some that are OK:
  var nudged = true;
  for (var offset = 0; offset &#x3c; points.Length &#x26;&#x26; nudged; offset += 2) {
var x = Math.floor (points[offset]);
var y = Math.floor( points[offset + 1]);
if (x &#x3c; - 1 || x &#x3e; width || y &#x3c; - 1 || y &#x3e; height)
    {
      throw &#x22;Error.checkAndNudgePoints &#x22;;
    }
    nudged = false;
    if (x == - 1)
    {
      points[offset] = 0.0;
      nudged = true;
    }
    else if (x == width)
    {
      points[offset] = width - 1;
      nudged = true;
    }
    if (y == - 1)
    {
      points[offset + 1] = 0.0;
      nudged = true;
    }
    else if (y == height)
    {
      points[offset + 1] = height - 1;
      nudged = true;
    }
  }
  // Check and nudge points from end:
  nudged = true;
  for (var offset = points.Length - 2; offset &#x3e;= 0 &#x26;&#x26; nudged; offset -= 2)
  {
    var x = Math.floor( points[offset]);
    var y = Math.floor( points[offset + 1]);
    if (x &#x3c; - 1 || x &#x3e; width || y &#x3c; - 1 || y &#x3e; height)
    {
      throw &#x22;Error.checkAndNudgePoints &#x22;;
    }
    nudged = false;
    if (x == - 1)
    {
      points[offset] = 0.0;
      nudged = true;
    }
    else if (x == width)
    {
      points[offset] = width - 1;
      nudged = true;
    }
    if (y == - 1)
    {
      points[offset + 1] = 0.0;
      nudged = true;
    }
    else if (y == height)
    {
      points[offset + 1] = height - 1;
      nudged = true;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
{
  points[x] =  (x &#x3e;&#x3e; 1) + 0.5;
  points[x + 1] = iValue;
}
transform.transformPoints1(points);
// Quick check to see if points transformed to something inside the image;
// sufficient to check the endpoints
GridSampler.<span class="apidocCodeKeywordSpan">checkAndNudgePoints</span>(image, points);
try
{
  for (var x = 0; x &#x3c; max; x += 2)
  {
    var xpoint = (Math.floor( points[x]) * 4) + (Math.floor( points[x + 1]) * qrcode.width * 4);
                var bit = image[Math.floor( points[x])+ qrcode.width* Math.floor( points[x + 1])];
    qrcode.imagedata.data[xpoint] = bit?255:0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.grid.sampleGrid3" id="apidoc.element.jsqrcode.grid.sampleGrid3">
        function <span class="apidocSignatureSpan">jsqrcode.grid.</span>sampleGrid3
        <span class="apidocSignatureSpan">( image, dimension, transform)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sampleGrid3 = function ( image, dimension, transform)
{
  var bits = new BitMatrix(dimension);
  var points = new Array(dimension &#x3c;&#x3c; 1);
  for (var y = 0; y &#x3c; dimension; y++)
  {
    var max = points.length;
    var iValue =  y + 0.5;
    for (var x = 0; x &#x3c; max; x += 2)
    {
      points[x] =  (x &#x3e;&#x3e; 1) + 0.5;
      points[x + 1] = iValue;
    }
    transform.transformPoints1(points);
    // Quick check to see if points transformed to something inside the image;
    // sufficient to check the endpoints
    GridSampler.checkAndNudgePoints(image, points);
    try
    {
      for (var x = 0; x &#x3c; max; x += 2)
      {
        var xpoint = (Math.floor( points[x]) * 4) + (Math.floor( points[x + 1]) * qrcode.width * 4);
                    var bit = image[Math.floor( points[x])+ qrcode.width* Math.floor( points[x + 1])];
        qrcode.imagedata.data[xpoint] = bit?255:0;
        qrcode.imagedata.data[xpoint+1] = bit?255:0;
        qrcode.imagedata.data[xpoint+2] = 0;
        qrcode.imagedata.data[xpoint+3] = 255;
        //bits[x &#x3e;&#x3e; 1][ y]=bit;
        if(bit)
          bits.set_Renamed(x &#x3e;&#x3e; 1, y);
      }
    }
    catch ( aioobe)
    {
      // This feels wrong, but, sometimes if the finder patterns are misidentified, the resulting
      // transform gets &#x22;twisted&#x22; such that it maps a straight line of points to a set of points
      // whose endpoints are in bounds, but others are not. There is probably some mathematical
      // way to detect this about the transformation that I don&#x27;t know yet.
      // This results in an ugly runtime exception despite our clever checks above -- can&#x27;t have
      // that. We could check each point&#x27;s coordinates but that feels duplicative. We settle for
      // catching and wrapping ArrayIndexOutOfBoundsException.
      throw &#x22;Error.checkAndNudgePoints&#x22;;
    }
  }
  return bits;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return transform;
  }

this.sampleGrid = function( image,  transform,  dimension)
  {

    var sampler = grid;
    return sampler.<span class="apidocCodeKeywordSpan">sampleGrid3</span>(image, dimension, transform);
  }

this.processFinderPatternInfo = function( info)
  {

    var topLeft = info.TopLeft;
    var topRight = info.TopRight;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.grid.sampleGridx" id="apidoc.element.jsqrcode.grid.sampleGridx">
        function <span class="apidocSignatureSpan">jsqrcode.grid.</span>sampleGridx
        <span class="apidocSignatureSpan">( image, dimension, p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY , p3FromX, p3FromY, p4FromX, p4FromY)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sampleGridx = function ( image, dimension, p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY , p3FromX, p3FromY, p4FromX, p4FromY)
{
  var transform = PerspectiveTransform.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX
, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);

  return GridSampler.sampleGrid3(image, dimension, transform);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.perspective_transform" id="apidoc.module.jsqrcode.perspective_transform">module jsqrcode.perspective_transform</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.perspective_transform.perspective_transform" id="apidoc.element.jsqrcode.perspective_transform.perspective_transform">
        function <span class="apidocSignatureSpan">jsqrcode.</span>perspective_transform
        <span class="apidocSignatureSpan">( a11, a21, a31, a12, a22, a32, a13, a23, a33)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PerspectiveTransform( a11, a21, a31, a12, a22, a32, a13, a23, a33)
{
	this.a11 = a11;
	this.a12 = a12;
	this.a13 = a13;
	this.a21 = a21;
	this.a22 = a22;
	this.a23 = a23;
	this.a31 = a31;
	this.a32 = a32;
	this.a33 = a33;
	this.transformPoints1=function( points)
		{
			var max = points.length;
			var a11 = this.a11;
			var a12 = this.a12;
			var a13 = this.a13;
			var a21 = this.a21;
			var a22 = this.a22;
			var a23 = this.a23;
			var a31 = this.a31;
			var a32 = this.a32;
			var a33 = this.a33;
			for (var i = 0; i &#x3c; max; i += 2)
			{
				var x = points[i];
				var y = points[i + 1];
				var denominator = a13 * x + a23 * y + a33;
				points[i] = (a11 * x + a21 * y + a31) / denominator;
				points[i + 1] = (a12 * x + a22 * y + a32) / denominator;
			}
		}
	this. transformPoints2=function(xValues, yValues)
		{
			var n = xValues.length;
			for (var i = 0; i &#x3c; n; i++)
			{
				var x = xValues[i];
				var y = yValues[i];
				var denominator = this.a13 * x + this.a23 * y + this.a33;
				xValues[i] = (this.a11 * x + this.a21 * y + this.a31) / denominator;
				yValues[i] = (this.a12 * x + this.a22 * y + this.a32) / denominator;
			}
		}

	this.buildAdjoint=function()
		{
			// Adjoint is the transpose of the cofactor matrix:
			return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21
 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12
 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11
 * this.a22 - this.a12 * this.a21);
		}
	this.times=function( other)
		{
			return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this
.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11
 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other
.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 +this.a33 * other.a13, this.a13 *
other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
		}

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.perspective_transform.quadrilateralToQuadrilateral" id="apidoc.element.jsqrcode.perspective_transform.quadrilateralToQuadrilateral">
        function <span class="apidocSignatureSpan">jsqrcode.perspective_transform.</span>quadrilateralToQuadrilateral
        <span class="apidocSignatureSpan">( x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">quadrilateralToQuadrilateral = function ( x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p)
{
	
	var qToS = this.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
	var sToQ = this.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
	return sToQ.times(qToS);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    {
      // Don&#x27;t have an alignment pattern, just make up the bottom-right point
      bottomRightX = (topRight.X - topLeft.X) + bottomLeft.X;
      bottomRightY = (topRight.Y - topLeft.Y) + bottomLeft.Y;
      sourceBottomRightX = sourceBottomRightY = dimMinusThree;
    }

    var transform = PerspectiveTransform.<span class="apidocCodeKeywordSpan">quadrilateralToQuadrilateral</span>(3.5, 3.5, dimMinusThree
, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.X, topLeft.Y, topRight.X, topRight.Y, bottomRightX, bottomRightY
, bottomLeft.X, bottomLeft.Y);

    return transform;
  }

this.sampleGrid = function( image,  transform,  dimension)
  {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.perspective_transform.quadrilateralToSquare" id="apidoc.element.jsqrcode.perspective_transform.quadrilateralToSquare">
        function <span class="apidocSignatureSpan">jsqrcode.perspective_transform.</span>quadrilateralToSquare
        <span class="apidocSignatureSpan">( x0, y0, x1, y1, x2, y2, x3, y3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">quadrilateralToSquare = function ( x0, y0, x1, y1, x2, y2, x3, y3)
{
	// Here, the adjoint serves as the inverse:
	return this.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}

}

PerspectiveTransform.quadrilateralToQuadrilateral=function( x0,  y0,  x1,  y1,  x2,  y2,  x3,  y3,  x0p,  y0p,  x1p,  y1p,  x2p,
y2p,  x3p,  y3p)
{
	
	var qToS = this.<span class="apidocCodeKeywordSpan">quadrilateralToSquare</span>(x0, y0, x1, y1, x2, y2, x3, y3);
	var sToQ = this.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
	return sToQ.times(qToS);
}

PerspectiveTransform.squareToQuadrilateral=function( x0,  y0,  x1,  y1,  x2,  y2,  x3,  y3)
{
	 dy2 = y3 - y2;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.perspective_transform.squareToQuadrilateral" id="apidoc.element.jsqrcode.perspective_transform.squareToQuadrilateral">
        function <span class="apidocSignatureSpan">jsqrcode.perspective_transform.</span>squareToQuadrilateral
        <span class="apidocSignatureSpan">( x0, y0, x1, y1, x2, y2, x3, y3)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">squareToQuadrilateral = function ( x0, y0, x1, y1, x2, y2, x3, y3)
{
	 dy2 = y3 - y2;
	 dy3 = y0 - y1 + y2 - y3;
	if (dy2 == 0.0 &#x26;&#x26; dy3 == 0.0)
	{
		return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0.0, 0.0, 1.0);
	}
	else
	{
		 dx1 = x1 - x2;
		 dx2 = x3 - x2;
		 dx3 = x0 - x1 + x2 - x3;
		 dy1 = y1 - y2;
		 denominator = dx1 * dy2 - dx2 * dy1;
		 a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
		 a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
		return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23
, 1.0);
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

}

PerspectiveTransform.quadrilateralToQuadrilateral=function( x0,  y0,  x1,  y1,  x2,  y2,  x3,  y3,  x0p,  y0p,  x1p,  y1p,  x2p,
y2p,  x3p,  y3p)
{
	
	var qToS = this.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
	var sToQ = this.<span class="apidocCodeKeywordSpan">squareToQuadrilateral</span>(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
	return sToQ.times(qToS);
}

PerspectiveTransform.squareToQuadrilateral=function( x0,  y0,  x1,  y1,  x2,  y2,  x3,  y3)
{
	 dy2 = y3 - y2;
	 dy3 = y0 - y1 + y2 - y3;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsqrcode.version" id="apidoc.module.jsqrcode.version">module jsqrcode.version</a></h1>


    <h2>
        <a href="#apidoc.element.jsqrcode.version.version" id="apidoc.element.jsqrcode.version.version">
        function <span class="apidocSignatureSpan">jsqrcode.</span>version
        <span class="apidocSignatureSpan">( versionNumber, alignmentPatternCenters, ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Version( versionNumber, alignmentPatternCenters, ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4)
{
  this.versionNumber = versionNumber;
  this.alignmentPatternCenters = alignmentPatternCenters;
  this.ecBlocks = new Array(ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4);

  var total = 0;
  var ecCodewords = ecBlocks1.ECCodewordsPerBlock;
  var ecbArray = ecBlocks1.getECBlocks();
  for (var i = 0; i &#x3c; ecbArray.length; i++)
  {
    var ecBlock = ecbArray[i];
    total += ecBlock.Count * (ecBlock.DataCodewords + ecCodewords);
  }
  this.totalCodewords = total;

  this.__defineGetter__(&#x22;VersionNumber&#x22;, function()
  {
    return  this.versionNumber;
  });

  this.__defineGetter__(&#x22;AlignmentPatternCenters&#x22;, function()
  {
    return  this.alignmentPatternCenters;
  });
  this.__defineGetter__(&#x22;TotalCodewords&#x22;, function()
  {
    return  this.totalCodewords;
  });
  this.__defineGetter__(&#x22;DimensionForVersion&#x22;, function()
  {
    return  17 + 4 * this.versionNumber;
  });

  this.buildFunctionPattern=function()
    {
      var dimension = this.DimensionForVersion;
      var bitMatrix = new BitMatrix(dimension);

      // Top left finder pattern + separator + format
      bitMatrix.setRegion(0, 0, 9, 9);
      // Top right finder pattern + separator + format
      bitMatrix.setRegion(dimension - 8, 0, 8, 9);
      // Bottom left finder pattern + separator + format
      bitMatrix.setRegion(0, dimension - 8, 9, 8);

      // Alignment patterns
      var max = this.alignmentPatternCenters.length;
      for (var x = 0; x &#x3c; max; x++)
      {
        var i = this.alignmentPatternCenters[x] - 2;
        for (var y = 0; y &#x3c; max; y++)
        {
          if ((x == 0 &#x26;&#x26; (y == 0 || y == max - 1)) || (x == max - 1 &#x26;&#x26; y == 0))
          {
            // No alignment patterns near the three finder paterns
            continue;
          }
          bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);
        }
      }

      // Vertical timing pattern
      bitMatrix.setRegion(6, 9, 1, dimension - 17);
      // Horizontal timing pattern
      bitMatrix.setRegion(9, 6, dimension - 17, 1);

      if (this.versionNumber &#x3e; 6)
      {
        // Version info, top right
        bitMatrix.setRegion(dimension - 11, 0, 3, 6);
        // Version info, bottom left
        bitMatrix.setRegion(0, dimension - 11, 6, 3);
      }

      return bitMatrix;
    }
  this.getECBlocksForLevel=function( ecLevel)
  {
    return this.ecBlocks[ecLevel.ordinal()];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.version.decodeVersionInformation" id="apidoc.element.jsqrcode.version.decodeVersionInformation">
        function <span class="apidocSignatureSpan">jsqrcode.version.</span>decodeVersionInformation
        <span class="apidocSignatureSpan">( versionBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decodeVersionInformation = function ( versionBits)
{
  var bestDifference = 0xffffffff;
  var bestVersion = 0;
  for (var i = 0; i &#x3c; Version.VERSION_DECODE_INFO.length; i++)
  {
    var targetVersion = Version.VERSION_DECODE_INFO[i];
    // Do the version info bits match exactly? done.
    if (targetVersion == versionBits)
    {
      return this.getVersionForNumber(i + 7);
    }
    // Otherwise see if this is the closest to a real version info bit string
    // we have seen so far
    var bitsDifference = FormatInformation.numBitsDiffering(versionBits, targetVersion);
    if (bitsDifference &#x3c; bestDifference)
    {
      bestVersion = i + 7;
      bestDifference = bitsDifference;
    }
  }
  // We can tolerate up to 3 bits of error since no two version info codewords will
  // differ in less than 4 bits.
  if (bestDifference &#x3c;= 3)
  {
    return this.getVersionForNumber(bestVersion);
  }
  // If we didn&#x27;t find a close enough match, fail
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
{
  for (var i = dimension - 9; i &#x3e;= ijMin; i--)
  {
    versionBits = this.copyBit(i, j, versionBits);
  }
}

this.parsedVersion = Version.<span class="apidocCodeKeywordSpan">decodeVersionInformation</span>(versionBits);
if (this.parsedVersion != null &#x26;&#x26; this.parsedVersion.DimensionForVersion == dimension)
{
  return this.parsedVersion;
}

// Hmm, failed. Try bottom left: 6 wide by 3 tall
versionBits = 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.version.getProvisionalVersionForDimension" id="apidoc.element.jsqrcode.version.getProvisionalVersionForDimension">
        function <span class="apidocSignatureSpan">jsqrcode.version.</span>getProvisionalVersionForDimension
        <span class="apidocSignatureSpan">(dimension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getProvisionalVersionForDimension = function (dimension)
{
  if (dimension % 4 != 1)
  {
    throw &#x22;Error getProvisionalVersionForDimension&#x22;;
  }
  try
  {
    return Version.getVersionForNumber((dimension - 17) &#x3e;&#x3e; 2);
  }
  catch ( iae)
  {
    throw &#x22;Error getVersionForNumber&#x22;;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);
if (moduleSize &#x3c; 1.0)
{
  throw &#x22;Error&#x22;;
}
var dimension = this.computeDimension(topLeft, topRight, bottomLeft, moduleSize);
var provisionalVersion = Version.<span class="apidocCodeKeywordSpan">getProvisionalVersionForDimension</span>(dimension);
var modulesBetweenFPCenters = provisionalVersion.DimensionForVersion - 7;

var alignmentPattern = null;
// Anything above version 1 has an alignment pattern
if (provisionalVersion.AlignmentPatternCenters.length &#x3e; 0)
{
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsqrcode.version.getVersionForNumber" id="apidoc.element.jsqrcode.version.getVersionForNumber">
        function <span class="apidocSignatureSpan">jsqrcode.version.</span>getVersionForNumber
        <span class="apidocSignatureSpan">( versionNumber)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getVersionForNumber = function ( versionNumber)
{
  if (versionNumber &#x3c; 1 || versionNumber &#x3e; 40)
  {
    throw &#x22;ArgumentException&#x22;;
  }
  return Version.VERSIONS[versionNumber - 1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var dimension = this.bitMatrix.Dimension;

var provisionalVersion = (dimension - 17) &#x3e;&#x3e; 2;
if (provisionalVersion &#x3c;= 6)
{
  return Version.<span class="apidocCodeKeywordSpan">getVersionForNumber</span>(provisionalVersion);
}

// Read top-right version info: 3 wide by 6 tall
var versionBits = 0;
var ijMin = dimension - 11;
for (var j = 5; j &#x3e;= 0; j--)
{
...</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
